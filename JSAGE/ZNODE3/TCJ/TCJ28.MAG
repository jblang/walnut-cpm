The ZSIG Column #4, March 9, 1987


                              The ZSIG Corner

                                  Jay Sage



     For this issue I will finally get to my long promised discussion ofç
techniques for customizing the Z-COM automatic installation version of theç
Z-System.  Before turning to the main subject, however, there are two otherç
items I would like to cover.  One is some follow-on discussion to theç
material I presented last time on recursive aliases; the other is aç
description of the latest ZSIG releases.


                         More on Recursive Aliases
			 -------------------------


     Art Carlson forwarded to me a letter he received from Dreas Nielsen inç
response to my discussion of recursive alias techniques using VALIAS andç
ARUNZ.  Dreas, well known in the ZCPR community for his excellent shellç
utility programs, GETVAR and RESOLVE, took me to task for doing somethingç
the hard (and not quite correct) way when there was a not-too-hard andç
completely correct way to do it.  And he proved it by offering a marvelousç
technique for 'recursing' aliases without any of the problems I warned aboutç
with my technique.  To me this is a wonderful example of the richness ofç
ZCPR3.  No matter how thoroughly one knows it, there are always significantç
new techniques and applications to be discovered.  The learning andç
excitement never ends!

     We will illustrate the technique using a simple example based on theç
following script that is designed to display a message on the screen showingç
how many times it has been run already.  The script is

	alias ONELOOP:		ECHO THIS IS LOOP NUMBER
				REG P6

As the ZCPR3 user register number 6 is incremented using the 'P'-for-plusç
option, its new value is displayed on the screen.

     If we wanted to make the alias operate recursively, our first instinct,ç
as described in my previous column, would be to expand it to the following:

	alias MANYLOOP:		ECHO THIS IS LOOP NUMBER
				REG P6
				ECHO DO IT AGAIN?
				IF IN
				MANYLOOP
				FI

As I explained last time, the trouble with this is that each time we runç
through the loop by answering the input prompt affirmatively we go one IFçälevel deeper and accumulate another FI on the end of the command line. ç
Eventually either the command line becomes too long or, more likely, weç
exceed the allowed eight levels of IF nesting.

     Dreas's idea is based on turning this alias around so that there is noç
FI on the end to accumulate.  He permutes it to the beginning of the scriptç
and writes the alias this way:

	alias RECURSE2:		FI
				ECHO THIS IS LOOP NUMBER
				REG P6
				ECHO DO IT AGAIN?
				IF IN
				RECURSE2

If this alias is invoked with a 'true' IF level already in effect, this willç
work just fine.  The alias will drop one IF level lower at the FI command,ç
do its main work, and return to the original IF level with the "IF IN"ç
prompt.  If the answer is affirmative, we will be back in the very same IFç
state we were in when the alias was invoked the first time.  The alias willç
be re-invoked, and the whole operation will repeat.  On the other hand, ifç
the answer to the prompt is negative, the alias will stop running, and weç
will fall out the bottom at the same IF level as we entered originally butç
in the 'false' state.

     To deal with the need to enter one IF level higher and to terminate theç
'false' IF state at the end, we simply call the above alias from anotherç
alias with the following script:

	alias RECURSE:		IF TRUE
				RECURSE2
				FI

The "IF TRUE" command will push us one IF level deeper and put us in aç
'true' state.  (This, by the way, is the first time that I have ever seen aç
use for the "TRUE" option with the IF command.  If, like me, you neverç
implemented that option because you could not figure out what on earth itç
could possibly be used for, you can substitute any other option that isç
guaranteed to return a 'true' state, such as "IF NULL" with nothing after itç
or "IF A=A").  The RECURSE2 alias will now run as we described earlier, andç
when the recursion is terminated by a negative answer, the FI in RECURSEç
will terminate the resulting 'false' IF state and return us to the originalç
IF level that we were at when RECURSE was invoked.

     One has to stretch things a bit to come up with any disadvantages toç
this technique.  The best I can do is the following two minor points. ç
First, two aliases are required to get things started, and this will slowç
things down a bit, especially on a floppy-disk system.  Secondly, theç
technique, while simple in principle, may not be easy to remember when oneç
wants to set up a quick recursive alias, as in the application I describedç
in my last article.  The VALIAS/ARUNZ-type recursive alias may still beç
useful in such a case.

     If you are a purist and have a strong, perhaps even irresistible, urgeç
to do things right (and especially if you have a RAM disk so that you cançäafford to indulge such compulsions), Dreas's technique can be nicelyç
automated by creating the following two slightly more complex andç
generalized aliases:

	alias RECURSE		IF NULL $1
				ECHO SYNTAX: $0 ALIASNAME PARAMETERS
				ELSE
				RECURSE2 $*
				FI

	alias RECURSE2		FI
				$*
				ECHO RUN "$1" AGAIN?
				IF IN
				$0 $*

Now suppose we have our edit/assemble/link alias as follows (where it, inç
turn, calls on the SYSLINK alias to perform the linkage with the libraries):

	alias WORK		EDIT $1.Z80
				Z80ASM $1/R
				IF ~ERROR
				SYSLINK $1
				FI

     If we enter the command "RECURSE" all by itself, we will get the ç
message "SYNTAX: RECURSE ALIASNAME PARAMETERS".  If we enter the commandç
"RECURSE WORK MYPROG",  the "IF NULL" test in RECURSE will be 'false' butç
will be toggled 'true' by the ELSE command.  Then RECURSE2 will be invoked,ç
and the command line and IF status will progress as shown in Fig. 1.  Theç
"..." in the IF states designates any IF levels in effect at the time thatç
RECURSE was called.  Similarly, the command text 'pending' designates anyç
command-line text following the invocation of RECURSE.

     The figure does not show the operation of every command.  Theç
edit/assemble/syslink sequences are not shown in detail.  Between steps 8ç
and 9 we assume that the "IF IN" prompt was answered with a 'Y'.  Thisç
brings us at step 9 back to the exact state we were in at step 4, and stepsç
4 through 8 will be repeated over and over so long as the "IF IN" prompt isç
answered affirmatively.

     Between steps 10 and 11 we assume that the "IF IN" prompt was answeredç
with 'N', so we get the state shown in step 11.  Since the current IF stateç
is 'false', the command "RECURSE2 WORK MYPROG" is flushed, leaving us atç
step 12.  The FI command terminates the 'false' IF and drops the flow stateç
one level lower.  Any pending commands that were on the command line afterç
the invocation of RECURSE are now free to run at step 13.

     I just tested out these aliases on my SB180 by putting them into myç
ALIAS.CMD file, which lives on the RAM disk.  The scripts had to be alteredç
slightly, with all invocations of RECURSE2 from within RECURSE and RECURSE2ç
being replaced by "ARUNZ RECURSE2 ..." or "ARUNZ $0 ...".  They worked likeç
an absolute charm.  Thank you Dreas Nielsen!!!

------------------------------------------------------------------------------ä
	Step	IF state	Command Buffer Contents
	----	--------	-----------------------

	  1	...		RECURSE WORK MYPROG;pending

	  2	...		IF NULL WORK MYPROG;ECHO SYNTAX: RECURSE
				ALIASNAME PARAMETERS;ELSE;RECURSE2 WORK
				MYPROG;FI;pending

	  3	F...		ELSE;RECURSE2 WORK MYPROG;FI;pending

	  4	T...		RECURSE2 WORK MYPROG;FI;pending

	  5	T...		FI;WORK MYPROG;ECHO RUN "WORK" AGAIN?;
				IF IN;RECURSE2 WORK MYPROG;FI;pending

	  6	...		WORK MYPROG;ECHO RUN "WORK" AGAIN?;IF IN
				RECURSE2 WORK MYPROG;FI;pending

	  7	...		EDIT MYPROG.Z80;Z80ASM MYPROG/R;IF ~ERROR;
				SYSLINK MYPROG;FI;ECHO RUN "WORK" AGAIN?;
				IF IN;RECURSE2 WORK MYPROG;FI;pending

	  8	...		ECHO RUN "WORK" AGAIN?;IF IN;RECURSE2 WORK
				MYPROG;FI;pending

	  9	T...		RECURSE2 WORK MYPROG;FI;pending

	 10	...		ECHO RUN "WORK" AGAIN?;IF IN;RECURSE2 WORK
				MYPROG;FI;pending

	 11	F...		RECURSE2 WORK MYPROG;FI;pending

	 12	F...		FI;pending

	 13	...		pending

Fig. 1.  Evolution of the command line and IF states as the operation of theç
command "RECURSE WORK MYPROG" unfolds.

------------------------------------------------------------------------------


                            A Z-Letters Feature
			    -------------------


     Thanking Dreas Nielsen for his letter reminds me that Art Carlson and Iç
would like very much to start up a Z-Letters feature in TCJ, a kind ofç
letters-to-the-editor section specializing in Z-System questions, comments,ç
discussion, and ideas.  I am willing to handle answering or otherwiseç
responding to those letters, but I will depend on you readers to send themç
in.  And rest assured that we are not looking only for letters like Dreas'sç
containing brilliant suggestions.  A good set of simpleminded questionsçäwould be quite well appreciated, thank you.  They would help us a great dealç
in learning what aspects of Z-System are confusing to users so that we canç
try to clarify them.


                             New ZSIG Releases
			     -----------------


     We have quite a few excellent new programs to release on ZSIG diskettesç
this month.  I have not yet finalized exactly what will be included onç
release diskettes #2 and #3, but I don't want to pass up this opportunity toç
publicize them.

     First of all, I am very happy to report that all the programs Iç
proposed two issues back have now been written, and I will describe themç
first.

K;S4;I4
FCP10.LBR

	This is the new flow control package (FCP) that I wrote with valuableç
assistance from Howard Goldstein (New Haven, CT).  This program wasç
described in some detail in the last column, so I will not say too muchç
about it here.  The two most important innovations are 1) the additionç
of AND and OR commands and 2) the FCP's ability to load and run IF.COMç
in high memory where it will not interfere with data in the beginning ofç
the transient program area at 100H.

COMIF10.LBR

	This is the companion transient IF processor that is intended to replaceç
IF.COM.  Also described last time, it offers an enormous number of newç
test conditions and syntax forms. This one was also written by meç
together with Howard Goldstein.

SETPATH1.LBR

	This is an extended version of the original PATH command.  It allows oneç
optionally to add and remove path elements from the beginning or the endç
of the existing path.  The path display is also improved.  Robertç
Demrow, a fellow member of the Boston Computer Society CP/M Group wroteç
this one.

EDITND.LBR

	Al Hawley (Z-Node #3 in Los Angeles) really went all out with tools toç
work with the named directory register (NDR).  EDITND lets one edit theç
names directly in the NDR.  Names and/or passwords can be added,ç
deleted, and changed.

SAVNDR.LBR

	After you've edited the NDR, this program lets you save the results toç
an NDR file.  Again by Al Hawley.ä
LOADND12.LBR

	The last in the Hawley set, this program can automatically update theç
names in the NDR using either the special file name system in LDSK or byç
loading an NDR file whose names are applied to the current floppy diskç
only.


The next ZSIG release will also include the following programs.

ZPATCH11.LBR

	This is another masterpiece from Steve Cohen (Chicago, author of 'W',ç
the wildcard shell, on the first ZSIG diskette).  It is by far the bestç
file patcher I have ever seen -- a real joy to use.  Steve sure isç
clever when it comes to shells!  Who would have thought to make a fileç
patcher into a shell?  But this way one can run a command from insideç
ZPATCH and then return to one's exact place to continue working.  Theç
'X' command in ZPATCH automatically runs the file one is currentlyç
patching (provided it is a COM file) so that one can see the effect ofç
the changes.  Marvelous!

MEX2Z.LBR

	This is yet another brainstorm of NAOG chief Bruce Morgen (who has quiteç
a stormy brain).  MEX2Z and my adaptation of it for MEX-Plus, MEX+2Z,ç
give the MEX communication programs the ability to 'shell', that is, toç
run a Z-System command apparently from within MEX.  For example, if youç
enter the MEX command line "CPM;CRUNCH FN.FT", you will exit from MEX,ç
the file will be crunched, and then you go right back into MEX.  This isç
especially handy when you are trying to debug a MEX script.  Bruceç
picked up on the very clever trick introduced by Ted Emigh in FINDERR,ç
namely, running a program that examines information left behind inç
memory by the program that ran before it.  In this case it is the MEXç
command line buffer that is picked up.  Even if you don't use MEX, it isç
worth looking at these programs just for their educational value.

FF10.LBR

	I finally decided to do something about the shortcomings of FINDF, theç
utility for determining where files are located in your system.  FF hasç
a 16-bit configuration word that can be patched (roll out ZPATCH!) toç
define which drives should be searched by default (this is particularlyç
useful when your constellation of drives has a hole in it, such as A, B,ç
C, and F).  You can override the default drive list by specifying a setç
of drives to scan on the command line.  A whole list of fileç
specifications can be given, and each one is automatically wildcarded,ç
saving the user a lot of typing.  If you want to find all programsç
starting with "SD", just enter "FF SD".  The "SD" turns into "SD*.*"ç
automatically.  Similarly, "FF .LBR" will find all library files.  "FFç
SD,.LBR" will find both.

PPIP15.LBR
ä	This is the next step in the evolution of PPIP (PPIP14 is on ZSIGç
diskette #1).  The main addition is support for DateStamper time andç
date stamping.  Having fallen in love with DateStamper, I just had toç
have some file copying tools that would preserve the time and dateç
information, so I added that capability to PPIP and to ZFILER.

ERRSET11.LBR

	This little tool lets you either display the current or directly enter aç
new error handler command line.  Strictly speaking, error handling inç
ZCPR3 is not performed by loading an error handling program but byç
executing an error handling command line.  This command line is storedç
in a 16-byte string in the message buffer.  When an error handler isç
installed by invoking its name manually from the command line, it writesç
only its name alone into that buffer.  ERRSET lets you enter a completeç
error command line, such as A15:VERROR.  By including an explicit DU: orç
DIR: form, the error handler will be found and loaded faster.  On theç
other hand, ERRSET will let you enter the name of a nonexistent errorç
handler, so watch out.  Power has its price.  Written by yours truly.



R76;I8
                             Customizing Z-COM
			     -----------------


     We now turn to the piece-de-resistance for this article -- a discussionç
of techniques for customizing Echelon's automatically installing Z-Systemç
package known as Z-COM.  This will be the first of a two-part series.  Thisç
time I will cover the more elementary aspects of the subject, thoseç
modifications that can be made by changing only data structures in the Z-COMç
files.  Next time I will delve into customization techniques that involveç
serious hacking (such as modifying the Z-COM code itself).

     I will begin with an overview of what Z-COM is, the philosophy behindç
it, the procedure for installing it on a particular computer, and how oneç
uses it to create a Z-System automatically.  Then I will give an elementaryç
discussion of how it works and the structure of the COM file that magicallyç
transforms one's ordinary CP/M machine into a 'Z' machine.  Next I will showç
you how to make some simple patches that eliminate the initializationç
operations that are performed by the startup file and make Z-COM come upç
ready to go instantly.  This includes setting the wheel byte, defining theç
symbolic command search path, putting in the terminal capability descriptorç
(TCAP) for the user's terminal, installing the user's named directories,ç
installing an external error handler, and even setting up an initial shell.

     With those techniques mastered, we can then go on to make changes toç
the system modules.  The simplest of these is replacing the standard ZRDOSç
that comes with Z-COM with the latest-and-greatest Public-ZRDOS-Plus versionç
1.7.   Slightly more complex is the replacement of the environmentç
descriptor (ENV) and the two command modules: the RCP (resident commandç
package) and the FCP (flow control package).  For these changes we have toç
edit some configuration files, assemble new code modules, and install theç
new modules into the Z-COM file.  By this point you will be ready toçägenerate and install a new version of the ZCPR3 command processor, anç
operation that requires one important extra step (a simple one, but one thatç
must not be overlooked).


                                 Why Z-COM


     Consider this situation.  The Z-System is a wonderful replacement forç
CP/M, one that greatly enhances the utility and ease of operation of anç
8-bit Z80-compatible computer.  I can't understand why anyone would notç
enjoy and benefit from its features and capabilities.  However, installingç
it in the conventional fashion required changing the BIOS (Basic Inputç
Output System), the hardware-dependent part of the operating system. ç
Unfortunately, many (actually most) manufacturers consider their BIOS to beç
proprietary (or embarrassingly poorly written), and they refuse to releaseç
the source code.  And even if they do make it available, perhaps for anç
extra fee, what if you do not know how to make the required changes toç
support the ZCPR3 command processor?  Well, enter Z-COM.

     Z-COM was the brilliant conception of Joe Wright, the nation'sç
preeminent BIOS writer (author of the BIOSes for the Ampro Little Board,ç
Micromint SB180, and the soon-to-be-available ON! computer from Oneac). ç
With Z-COM one does not need the BIOS source code because there are noç
changes to make in it.  One doesn't even need MOVCPM.  Z-COM runs on almostç
any standard CP/M 2.2 system, converting it in situ to a Z-System.  Thereç
are a few CP/M 2.2 computers on which Z-COM will not work (usually becauseç
at least some part of their memory space operates in a funny way), but theç
great majority will.  For those of you with CP/M version 3 (aka CP/M-Plus --ç
a real misnomer in my opinion), I'm afraid you are out of luck.  CP/M 3 isç
fundamentally different from CP/M 2.2, and no one has yet been able toç
concoct magic powerful enough to transform it into a Z-System.

     I hope my discussion here will inspire some of you to purchase Z-COM. ç
If it does, then see the ads in TCJ by Sage Microsystems East and Echelonç
for more information.  I personally think that a modified Z-COM is the bestç
way to implement Z-System, because, as we will see by the end of this seriesç
of articles, it gives one far greater flexibility than with a manuallyç
installed system.


                              Installing Z-COM


     Here is a brief description of how one gets Z-COM running on one'sç
system.  The standard procedure goes like this.  Take a freshly formattedç
disk, 'sysgen' the CP/M 2.2 operating system to it, copy onto it all theç
files on the Z-COM release disk, put this disk into drive A, and reboot theç
system either with the reset button or by entering control-c.  Now enter theç
command "SUB ZCCOM".  This starts a batch operation, and you can now sitç
back, relax, and watch your computer do all the work.  Toward the end of theç
process, which takes a couple of minutes, a program called TCSELECT will runç
and ask you to choose your terminal from a large menu.  The result will be aç
file called MYTERM.Z3T containing information about your terminal thatç
permits Z-System programs to perform screen operations without installation.ä

                    What's Going On During Installation


     In the first part of the installation process, the Z-COM systemç
creation program ZCLD.COM determines the memory address at which your BIOSç
operates and generates a corresponding Z-System.  To do this, it reads in aç
number of special relocatable files (most with file type SPR, which standsç
for system page relocatable) and produces four new files: ZC.COM, ZCX.COM,ç
ZC.ENV, and ZC.CP.  The first file, whose operation we will describe inç
detail below, is the one that transforms the vanilla CP/M system to theç
amaretto-double-chocolate almond Z-System with jimmies (if you don't knowç
what jimmies are, ask someone from Boston).

     The second file, ZCX.COM, is a program that transforms you back.  Why,ç
you ask, would one ever go back to vanilla after experiencing the ecstasy ofç
amaretto-double-chocolate-almond?  Well, Z-System does have one significantç
drawback.  You don't get all those great features for free.  They cost aç
considerable chunk of TPA (transient program area) -- 5.5K in the case of Z-COM (though we will see next time how to reduce this if you are willing toç
forego some of the features).  The smaller TPA has almost never caused anyç
problem with the programs I use, but some people do have problems, and it isç
nice to know that a simple "ZCX" command will bring back the old CP/M withç
its full-sized TPA.  Next time I will explain how we can even change to aç
different Z-COM system with a larger TPA.

     The third file, ZC.ENV, is the environment descriptor file for theç
system that ZCLD created.  It is automatically included in ZC.COM, so itç
does not have to be loaded using LDR, but it is used by Z3INS to install theç
environment information into the utilities.

     The last file, ZC.CP, does not even appear in a directory listing; itç
is hidden up in user area 15, out of harm's way.  The user is not normallyç
concerned with this file, though if you want to create another Z-COM systemç
disk, you have to remember to copy it, as well as the others mentionedç
above, to the new diskette.  We will discuss its purpose later.


                              How ZC.COM Works


     As we said above, ZC.COM is the program that transforms your mundaneç
CP/M system into an exciting and powerful Z-System.  How does it do it? ç
Several simple principles are involved.

     ZC.COM is basically a loader program.  The file itself consists of twoç
parts.  The first page of code (100H to 1FFH) is the loader code.  Theç
second part (200H to 2DFFH) is the memory image of a Z-System that is copiedç
into place by the loader.  The process is like the 'big bang' theory ofç
creation -- the whole Z-System just appears complete in one operation!

     The memory map of the ZCOM-System generated for my BigBoard I computer,ç
on which I performed these experiments, is shown in Fig. 2.  Its real CP/Mç
BIOS is at E800H.  The Z-System addresses were determined by running theç
utility SHOW.COM after Z-COM was loaded.  The corresponding addresses in theçäZC.COM file were obtained by inspecting it with a debugger.  Once a fewç
addresses (like the RCP and FCP, which have obvious headers), wereç
determined, the rest was obvious.  The ZC.COM system image is at a constantç
offset from the real system.  In this example, that offset is BA00H.  If Z-COM is installed on a different system, the real system addresses and theç
offset value will be different, but the addresses of the system segments inç
the ZC.COM image will be the same.  In general, the offset between theç
corresponding addresses will be 2E00H less that the address of the nativeç
BIOS.

-----------------------------------------------------------------------------

System Component		ZC.COM Address		System Address
----------------		--------------		--------------

  CPR				  0200 - 09FF		  BC00 - C3FF
  ZRDOS				  0A00 - 17FF		  C400 - D1FF
  Virtual BIOS			  1800 - 19FF		  D200 - D3FF
  Named Directory Register	  1A00 - 1AFF		  D400 - D4FF
  Shell Stack			  1B00 - 1B7F		  D500 - D57F
  Z3 Message Buffer		  1B80 - 1BCF		  D580 - D5CF
  External FCB			  1BD0 - 1BF3		  D5D0 - D5F3
  PATH				  1BF4 - 1BFE		  D5F4 - D5FE
  Wheel Byte			  1BFF - 1BFF		  D5FF - D5FF
  Environment Descriptor	  1C00 - 1C7F		  D600 - D67F
  TCAP				  1C80 - 1CFF		  D680 - D6FF
  Multiple Command Line		  1D00 - 1DCF		  D700 - D7CF
  External Stack		  1DD0 - 1DFF		  D7D0 - D7FF
  Resident Command Package	  1E00 - 25FF		  D800 - DFFF
  Flow Control Package		  2600 - 27FF		  E000 - E1FF
  I/O Package			  2800 - 2DFF		  E200 - E7FF

Fig. 2.  Addresses of system components in the ZC.COM file and in theç
example system for which it was generated.

-----------------------------------------------------------------------------

     How does this system function?  If you are familiar with Z systems, youç
probably recognize all of the system components above except for the oneç
called 'virtual BIOS'.  That is where the key to Z-COM lies.  Remember, weç
needed a BIOS that would run below the Z buffers, but we had no way toç
relocate the actual BIOS.  So instead we create a virtual BIOS -- a block ofç
code structured just like a real BIOS.  It has a table of jump instructions,ç
one after the other, that perform the required BIOS functions: CBOOT, WBOOT,ç
CONST, CONIN, CONOUT, LIST, and so on.  How does this virtual BIOS actuallyç
carry out those functions without knowing anything about the systemç
hardware?  Easy!  It simply jumps to the corresponding entry points in theç
real BIOS!

     Well, it actually is not quite that easy.  There are a few specialç
details that have to be taken care of.  Most of the functions are performedç
as described above, but there are some important exceptions.  The mostç
important one is the WBOOT, or warm boot, function.  Normally when a warmç
boot is performed, the CPR (and often the BDOS as well) is reloaded from theç
system tracks of the A diskette.  If that were allowed to happen here,ç
goodbye Z-System!  ZC.COM would only work until the first warm bootçäoccurred, and then we would have to run it again.  Not very satisfactory!

     To prevent that from happening and to keep Z-COM running, the virtualç
BIOS 'traps' warm boot calls.  That is a fancy way of saying that instead ofç
simply passing the call to the real BIOS it does the work itself.  What doesç
it do?  Well, it has to reload the ZCPR3 command processor to the properç
address, BC00H in this example.  Since the ZCPR command processor does notç
reside on the system tracks, we have to get it from somewhere else.  Joeç
Wright could have gotten it from records 2 through 17 in ZC.COM, but heç
chose instead to maintain a separate file with just the image of the commandç
processor.  Remember the file ZC.CP that we mentioned earlier, the oneç
stashed away in A15:?  That's it.

     Although I don't know of any reason why CBOOT, the cold boot routine,ç
would ever be called once the computer was initially booted up, the CBOOTç
routine is also trapped by the virtual BIOS and vectored (another fancyç
word) to the same code as the virtual warm boot.

     In Echelon's simpler auto-install package Z3-DOT-COM, which does notç
have support for Input/Output Packages (IOPs), the story would now beç
complete.  The IOP, however, has to get first shot at some of the BIOS I/Oç
routines, namely console status, console input, console output, list output,ç
list status, punch output, and reader input.  In a manual installation of Z-System with IOP support, the BIOS code would have to be modified.  With Z-COM this is quite straightforward.  The virtual BIOS calls to theseç
functions simply go (are vectored) to the appropriate entry points in theç
IOP module.  The initial IOP code included in ZC.COM is just a dummy IOPç
that simply turns around and forwards the calls from the IOP to the realç
BIOS entry points.


                             Easy Z-COM Patches


     Now that we understand what Z-COM is and how it works, we can start toç
make some changes.  If you look at the STRT startup alias with Z-COM, youç
will see that it turns on the wheel byte, loads the TCAP and named directoryç
register, and sets up the symbolic search path.  For our first set ofç
patches, we will eliminate the need for a startup alias.  We will make theç
system come up fully tailored to our preferences, and we will save the timeç
wasted by the STRT alias.

     The first step is to get Z-COM running and to use the utility programsç
to set it up as we like it.  We will generally turn the wheel byte on (theç
STRT alias presumably already ran WHEEL to do that for us).  We can set upç
our named directories using MKDIR and LDR or the new ZSIG named directoryç
editor EDITND.  We can choose our path using the PATH command or the newç
ZSIG SETPATH utility.  An external error handler can be defined in theç
message buffer by invoking the desired error handler manually at the commandç
line or by running the ERRSET utility (this can include a DU or DIRç
specifier to speed up the search for the error handler).  Finally, if weç
want to, we can even invoke a shell, such as the history shell HSH.

     Now all we have to do is clone this system using our favorite debugger. ç
If you can afford Echelon's DSD, I cannot recommend it highly enough.  Itç
will quickly spoil you.  On the other hand, I will describe here theç
procedure using Prof. Falconer's lovely DDTZ, a public-domain Zilog-mnemonicçäversion of DDT.  Here is the sequence of commands to use.  Don't forget thatç
the addresses that refer to the real system are the ones for my BigBoard. ç
You should make a table like that in Fig. 2 with the addresses for yourç
system and make the appropriate substitutions in the commands below.

    A0:SYS>ddtz zc.com		; Run debugger and load ZC.COM
    -md400,d6ff,1a00		; Copy running NDR, Shell Stack, MSG
				; ..buffer, PATH, WHL, ENV, and TCAP
				; ..into ZC.COM image
    -g0				; Exit from debugger
    A0:SYS>save 2dh zcnew.com	; Save new version of ZC

If you have a shell running while this process is being carried out, youç
have to include the SAVE command on the same line as the DDTZ command, sinceç
when the shell loads it wipes out the memory image in the TPA.  By puttingç
the SAVE command on the same line, it is run before the shell is reloaded.

     I have used the above technique and found it to work very nicely, but aç
word of caution is in order.  A purist would copy the memory areas only forç
the specific segments to be modified.  The external file control block andç
the parts of the message buffer other than the byte at offset 0 (D580, whereç
the error-handler-flag is kept) and bytes at offsets 10H to 1FH (D590-D59F,ç
where the error handler command line is kept) would not be copied.  Copyingç
the entire message buffer works as described above, but if you try to make aç
ZEX batch file to do this, you will get into trouble, since ZCNEW.COM willç
then contain an image of the message buffer with the ZEX-running flag set.

     To test ZCNEW, make a new STRT.COM alias that just echoes a signonç
message (first rename the old one in case you want it back later), run ZCXç
to exit from Z-COM, and then run ZCNEW.  Your own personalized Z-Systemç
should pop (almost) instantly to life.  After determining that it is reallyç
working correctly, you can rename ZCNEW.COM to ZC.COM.  Again, I recommendç
keeping old versions with names like ZC1.COM, ZC2.COM, and so on, on anç
archive disk.


                            Putting in a New DOS


     Now let's make a change that could not be accomplished using utilityç
programs, as all of the above changes could be.  Let's replace the older,ç
non-public version of ZRDOS that comes with Z-COM with the latest versionç
1.7 of Public-ZRDOS-Plus.  The first part of the process is same as that inç
a manually installed Z-System.  One takes the ZRDOS generating programç
ZRDINS17.COM, installs it using Z3INS, and runs it.  Having been installed,ç
it will automatically know the three facts it needs: where the DOS, ENV, andç
wheel byte are located.  After it finishes running, there will be a binaryç
image file called ZRDOS17.BIN.

     With a manually installed Z-System we would now have to go through aç
somewhat complex process involving 'sysgening' a system image from theç
system tracks, patching in the new DOS using a debugger, and 'sysgening' theç
image back onto the system tracks.  With Z-COM things are actuallyç
considerably easier, since the two 'sysgening' steps can be skipped.  Hereç
is the command sequence:ä
    A0:SYS>ddtz zc.com		; Run debugger and load ZC.COM
    -izrdos17.bin		; Initialize the file control block
    -r900			; Read with offset 900h so that the object
				; ..file will load at A00h
    -g0				; Warm boot out of debugger
    A0:SYS>save 2dh zcnew.com	; Save new version

As before, exit from Z-System with the ZCX command (or just hit the resetç
button if that is more convenient).  Then load the new system and run theç
DOSVER utility.  Voila!  There is version 1.7.

     Now let me show you a trick that makes patching even easier and doesn'tç
require a debugger at all.  Just use the following command sequence:

    A0:SYS>get 100 zc.com	; Load ZC.COM at address 100H
    A0:SYS>get a00 zrdos17.bin	; Load ZRDOS17.BIN at address A00H
    A0:SYS>save 2dh zcnew.com	; Save the new memory image

With this technique there is no computing of offsets, and it uses only ZCPR3ç
built-in commands (GET and SAVE).  The one thing you have to remember isç
that the GET command loads entire files, and so this technique can only beç
used to patch in things that come in contiguous blocks with a length that isç
an integral multiple of 128 bytes.  If you look at the memory table ofç
ZC.COM, however, you will see that this includes all system modules thatç
ever exist in the form of files: the CPR, DOS, NDR, ENV, TCAP, RCP, FCP, andç
IOP.  These patches can be done very nicely from alias scripts.  Forç
example, since one might often change one's named directories, the followingç
alias might be handy:

	alias PUTNDR:

		IF NULL $1
		ECHO SYNTAX: $0 NDR-FILE-NAME
		ELSE
		ERA ZCNEW.COM
		GET 100 ZC.COM
		GET 1A00 $1.NDR
		SAVE 1DH ZCNEW.COM
		ECHO TEST ZCNEW.COM
		FI

Similar aliases could be used for replacing other modules such as RCPs andç
FCPs.


                       New Command and System Modules


     Speaking of RCPs and FCPs, let's talk a little about how we generateç
new versions of these and other system modules.  There is no need to discussç
the patching techniques.  They are the same as what we have already seen. ç
The question is: how do we generate the new SYS.RCP, SYS.FCP, and SYS.ENVç
modules?
ä     The procedure is the same as in a manual install system, except that inç
a manual install system we already had the necessary Z3BASE.LIB file that isç
required for the assembly of new system modules.  So far we have not neededç
one with Z-COM.  To make things easier, Joe Wright has kindly provided usç
with a generalized Z3BASE.LIB file.  All we have to do to adapt it to ourç
system is to use an editor to fill in the address of the environmentç
descriptor in the "Z3ENV SET ..." definition near the top of the file.  Oneç
further hint: while you are at it, change the SET to an EQU.  If you useç
Z3BASE.LIB to assemble a file in Zilog mnemonics, the assembler will notç
accept SET, since that is a Zilog opcode.  You would have to change it toç
ASET in that case, but there is no reason not to use the universal EQU. ç
Some programs also require definitions for YES and NO, so you might want toç
add the lines:

		YES	EQU	TRUE
		NO	EQU	FALSE

One last addition.  The RCP, FCP, and ENV modules do not need it, but otherç
files, and most notably the command processor code, require an equate toç
define the address of the entry point to the command processor.  This is aç
part of the normal Z3BASE file, but Joe Wright forgot to put it in. ç
Someplace after the Z3ENV equate, add the line:

		CCP	EQU	Z3ENV - 1A00H

Now you should be all set to assemble up new system modules, like the newç
FCP10 from ZSIG.  You might also want to assemble a customized SYS.ENV withç
the correct values of maxdrive and maxuser and your own choice of printerç
and console definitions (see "ZCPR3, The Manual" for details).

     "ZCPR3, The Manual" explains in detail how to carry out the assemblies,ç
though I find that the discussion there makes the process look moreç
complicated than it really is.  Basically, you assemble the module to a HEXç
file, convert the HEX file to a COM file using MLOAD, and then rename theç
COM file to the proper name for the module (e.g., "REN SYS.FCP=FCP10.COM). ç
If you have the SLR assemblers, you can assemble the module directly to aç
COM in a single pass and skip the MLOAD step.  Finally you test the moduleç
by loading it using LDR.


                      Replacing the Command Processor


     Replacing the command processor is no more difficult than changing anyç
of the other modules in the system.  In fact, as we will soon see, it isç
much easier to test a new CPR with Z-COM than it is with the manuallyç
installed Z-System.

     The basic procedure is as we described for the RCP or FCP.  As usual,ç
edit the configuration LIB file (Z3HDR.LIB or Z31HDR.LIB if you are using myç
experimental version ZCPR315D) and assemble the code.  One additional hint. ç
Again, if you have the fabulous SLR Systems assemblers SLRMAC, Z80ASM, orç
SLR180, select the option to assemble directly to a COM file, not to a HEXç
file.  It is a shame that so many books and articles have taught theç
unnecessarily complex patching method based on HEX files with theirçäextremely tricky offset calculation.  It is much easier to work with a COMç
file where the load offset in the debugger is quite straightforward, namely,ç
100H below where you want the file to go, no matter what address it wasç
assembled for.  If you are using an assembler that can produce only a HEXç
file, then use the public-domain MLOAD to convert it to a COM file just asç
was done to make the RCP and FCP files.

     Now that you have ZCPR3.COM or some such file, all you have to do isç
substitute it for the file ZC.CP in A15:.  It would be a sign of foolhardyç
optimism to destroy the original ZC.CP.  I would recommend renaming it toç
something like ZCOLD.CP and then copying the new one into place with aç
command like "PPIP A15:ZC.CP=ZCPR3.COM".  Now just hit control-c to warmç
boot, and the new CPR will be running!

     If things did not work out as you intended (and especially if the newç
CPR just crashed the system), you can reboot and reload ZC.COM.  Remember,ç
you did not change the CPR image in ZC.COM yet, and things will be fine soç
long as you don't warm boot.  Before that happens, you should renameç
ZCOLD.CP back to ZC.CP.  Then you can try again.  That is sure a lot easierç
than all the 'sysgening' required to test a new CPR with the manuallyç
installed Z-System.

     If all went well, the system is now running just the way you hoped itç
would.  Once you've tested it and are satisfied that it really is workingç
correctly, you can patch the new CPR into ZC.COM so that it will be readyç
immediately after Z-COM loads.  The following commands will do it:

	A0:SYS>get 100 zc.com
	A0:SYS>get 200 a15:zc.cp
	A0:SYS>save 2dh zcnew.com

As usual, once you have verified that ZCNEW is working, rename it to ZC.COM.  


                             Summary and Plans
			     -----------------


     That wraps things up for this time.  You now know how to make enoughç
patches to mold a Z-COM system pretty well to your own tastes.  If you haveç
Z-COM, I hope you will experiment some before the next column appears.  Inç
that column we will really dig into Z-COM and do some wild things.  If youç
have any suggestions or questions, please send them along.  My address andç
phone numbers are listed below.

     As a little reward for those of you who plowed through this whole pieceç
(or who were taught the trick I was as a freshman in college to read the endç
of a paper or essay before you start at the beginning), here is a littleç
tidbit.  ZCPR version 3.3 is coming very soon.  I already have a nearlyç
complete version of it patched into the Z-COM I worked up for this article. ç
I expect that Z33 will have been released or will be very close to releaseç
by the time this column appears, and I will devote some space to aç
discussion of its new features in the next column.

					Jay Sageä					1435 Centre Street
					Newton Centre, MA 02159
					voice: 617-965-3552
					modem: 617-965-7259
