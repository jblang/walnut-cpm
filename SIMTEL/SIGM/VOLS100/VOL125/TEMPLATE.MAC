;
;  PROGRAM:  TEMPLATE
;  AUTHOR:  Richard Conn
;  VERSION:  1.2
;  DATE:  26 Apr 83
;  PREVIOUS VERSIONS:  1.1 (25 Apr 83), 1.0 (15 Jan 83)
;
VERS	equ	12

;
;	<< This is a Template designed to assist the programmer
;		in writing ZCPR2 Utilities >>
;	<< Insert a Description of the Program Here >>
;
;	TEMPLATE is provided as a template around which to build
; ZCPR2 utilities.  The body of TEMPLATE calls the following routines
; which must be provided for the specific function:
;
;		BANNER   -- Prints Name of Program
;		HELP     -- Prints Help Message
;		INIT     -- Performs Necessary Initializations
;		DINIT    -- Performs Necessary De-Initializations
;		OPTAB    -- Table of Command Line Options
;		FUNCTION -- Performs Function of Program
;		ABORT    -- Prints Abort Message and Exits
;
;	The flow of TEMPLATE is as follows:
;		1) Init ZCPR2 Buffers and Save Command Line
;		2) Print Banner by Calling BANNER
;		3) Call INIT Routine to Initialize Program
;		4) Process Command Line Options
;			-- OPTAB is used to specify option chars
;				and the routines used to process them
;			-- Each option character routine is provided
;				by the programmer
;		5) Print HELP Message if Invalid Option encountered
;		   and exit, calling DINIT on the way out
;		6) Select Files, allowing for Inspection
;		7) Call FUNCTION for each file selected; when FUNCTION
;		   is called, program has already been logged into the
;		   the directory containing the desired file and HL pts
;		   to the FCB of the desired file
;		8) Exit, calling DINIT on the way out
;
;	Nomenclature:
;		All Labels Used internal to TEMPLATE are prefixed with T$
;		All Labels Intended to be accessed by the programmer which
;			are a part of TEMPLATE are prefixed with E$ (External)
;		By employing such conventions, the programmer is relatively
;			free to employ any variable names he desires without
;			having to concern himself with labels and such used
;			by TEMPLATE
;

;
;	This program is Copyright (c) 1982, 1983 by Richard Conn
;	All Rights Reserved
;
;	ZCPR2 and its utilities, including this one, are released
; to the public domain.  Anyone who wishes to USE them may do so with
; no strings attached.  The author assumes no responsibility or
; liability for the use of ZCPR2 and its utilities.
;
;	The author, Richard Conn, has sole rights to this program.
; ZCPR2 and its utilities may not be sold without the express,
; written permission of the author.
;

FALSE	EQU	0
TRUE	EQU	NOT FALSE

;
;  BASIC SYSLIB ROUTINES NEEDED BY TEMPLATE
;
C$ESIZE	EQU	16	; SIZE OF DIR ENTRY (FROM SYSLIB DIRF ROUTINE)

	EXT	DIRFS	; DIRECTORY PROCESSOR
	EXT	DIRPACK	; PACK DIRECTORY

	EXT	ZGPINS	; INIT BUFFERS
	EXT	ZFNAME	; FILE NAME PROCESSOR

	EXT	INITFCB	; INIT FCB
	EXT	RETUD	; RETURN CURRENT USER/DISK
	EXT	PUTUD	; SAVE CURRENT USER/DISK
	EXT	GETUD	; RESTORE CURRENT USER/DISK
	EXT	LOGUD	; LOG INTO USER/DISK
	EXT	PRINT	; PRINT STRING PTED TO BY RET ADR
	EXT	PADC	; PRINT A AS DECIMAL CHARS
	EXT	COUT	; CONSOLE OUTPUT ROUTINE
	EXT	CST	; CONSOLE STATUS ROUTINE
	EXT	CIN	; CONSOLE INPUT ROUTINE
	EXT	CAPS	; CAPITALIZE ROUTINE
	EXT	CRLF	; NEW LINE ROUTINE
	EXT	CLINE	; COMMAND LINE STRING SAVE ROUTINE
	EXT	CODEND	; CODE END COMPUTATION ROUTINE

	EXT	F$OPEN	; FILE OPEN
	EXT	F$READ	; BLOCK READ
	EXT	F$CLOSE	; FILE CLOSE

;
;  Insert Function-Required Library References Here
;

;
;  CP/M EQUATES
;
CPM	EQU	0	; WARM BOOT
BDOSE	EQU	CPM+5	; BDOS ENTRY
FCB	EQU	CPM+5CH	; FCB
TBUFF	EQU	CPM+80H	; INPUT LINE BUFFER
DEL	EQU	7FH	; <DEL>
CR	EQU	13	; <CR>
FF	EQU	12	; <FF>
LF	EQU	10	; <LF>
CTRLC	EQU	'C'-'@'	; ^C
CTRLG	EQU	'G'-'@'
CTRLH	EQU	'H'-'@'
CTRLI	EQU	'I'-'@'
CTRLS	EQU	'S'-'@'
CTRLX	EQU	'X'-'@'
CTRLZ	EQU	'Z'-'@'

;
;  Branch to Start of Program
;
	JMP	T$START

;
;******************************************************************
;
;  SINSFORM -- ZCPR2 Utility Standard General Purpose Initialization Format
;
;	This data block precisely defines the data format for
; initial features of a ZCPR2 system which are required for proper
; initialization of the ZCPR2-Specific Routines in SYSLIB.
;

;
;  EXTERNAL PATH DATA
;
EPAVAIL:
	DB	0FFH	; IS EXTERNAL PATH AVAILABLE? (0=NO, 0FFH=YES)
EPADR:
	DW	40H	; ADDRESS OF EXTERNAL PATH IF AVAILABLE

;
;  INTERNAL PATH DATA
;
INTPATH:
	DB	0,0	; DISK, USER FOR FIRST PATH ELEMENT
			; DISK = 1 FOR A, '$' FOR CURRENT
			; USER = NUMBER, '$' FOR CURRENT
	DB	0,0
	DB	0,0
	DB	0,0
	DB	0,0
	DB	0,0
	DB	0,0
	DB	0,0	; DISK, USER FOR 8TH PATH ELEMENT
	DB	0	; END OF PATH

;
;  MULTIPLE COMMAND LINE BUFFER DATA
;
MCAVAIL:
	DB	0FFH	; IS MULTIPLE COMMAND LINE BUFFER AVAILABLE?
MCADR:
	DW	0FF00H	; ADDRESS OF MULTIPLE COMMAND LINE BUFFER IF AVAILABLE

;
;  DISK/USER LIMITS
;
MDISK:
	DB	4	; MAXIMUM NUMBER OF DISKS
MUSER:
	DB	31	; MAXIMUM USER NUMBER

;
;  FLAGS TO PERMIT LOG IN FOR DIFFERENT USER AREA OR DISK
;
DOK:
	DB	0FFH	; ALLOW DISK CHANGE? (0=NO, 0FFH=YES)
UOK:
	DB	0FFH	; ALLOW USER CHANGE? (0=NO, 0FFH=YES)

;
;  PRIVILEGED USER DATA
;
PUSER:
	DB	10	; BEGINNING OF PRIVILEGED USER AREAS
PPASS:
	DB	'chdir',0	; PASSWORD FOR MOVING INTO PRIV USER AREAS
	DS	41-($-PPASS)	; 40 CHARS MAX IN BUFFER + 1 for ending NULL

;
;  CURRENT USER/DISK INDICATOR
;
CINDIC:
	DB	'$'	; USUAL VALUE (FOR PATH EXPRESSIONS)

;
;  DMA ADDRESS FOR DISK TRANSFERS
;
DMADR:
	DW	80H	; TBUFF AREA

;
;  NAMED DIRECTORY INFORMATION
;
NDRADR:
	DW	00000H	; ADDRESS OF MEMORY-RESIDENT NAMED DIRECTORY
NDNAMES:
	DB	64	; MAX NUMBER OF DIRECTORY NAMES
DNFILE:
	DB	'NAMES   '	; NAME OF DISK NAME FILE
	DB	'DIR'		; TYPE OF DISK NAME FILE

;
;  REQUIREMENTS FLAGS
;
EPREQD:
	DB	000H	; EXTERNAL PATH?
MCREQD:
	DB	000H	; MULTIPLE COMMAND LINE?
MXREQD:
	DB	000H	; MAX USER/DISK?
UDREQD:
	DB	000H	; ALLOW USER/DISK CHANGE?
PUREQD:
	DB	000H	; PRIVILEGED USER?
CDREQD:
	DB	000H	; CURRENT INDIC AND DMA?
NDREQD:
	DB	000H	; NAMED DIRECTORIES?
Z2CLASS:
	DB	0	; CLASS 0
	DB	'ZCPR2'
	DS	10	; RESERVED

;
;  END OF SINSFORM -- STANDARD DEFAULT PARAMETER DATA
;
;******************************************************************
;

;
;  **** Special Initial Value Area for GENINS
;

;
;  Start of Program
;
T$START:
	LXI	H,0	; GET STACK PTR
	DAD	SP
	SHLD	V$STACK	; SAVE IT
	LXI	SP,V$STACK	; SET SP
	XRA	A	; A=0
	STA	V$INSPECT	; TURN OFF FILE INSPECTION
	CALL	PUTUD	; SAVE CURRENT USER/DISK AWAY
	CALL	RETUD	; GET CURRENT USER/DISK
	MOV	A,B	; SAVE DISK
	STA	V$DISK
	MOV	A,C	; SAVE USER
	STA	V$USER

	CALL	ZGPINS	; INIT BUFFERS

	LXI	H,TBUFF	; SAVE COMMAND LINE
	CALL	CLINE
	SHLD	V$CMDLNE	; SAVE PTR

;
;  Banner of Program
;
	CALL	BANNER	; PRINT BANNER PROVIDED BY USER
;
;  Check for Help Request
;
	LDA	FCB+1	; GET FIRST CHAR OF FILE NAME
	CPI	' '	; NO FILE SPEC?
	JZ	T$HELPENT
	CPI	'/'	; OPTION CAUGHT?
	JNZ	T$ECONT

;
;  Print Help Information
;
T$HELPENT:
	CALL	HELP	; PRINT PROGRAM'S HELP MESSAGE

;
;  RETURN TO OS
;
T$RETURN:
	CALL	DINIT	; DEINIT PROGRAM
	LHLD	V$STACK	; GET OLD STACK
	SPHL		; SET IT
	RET

;
;  PROGRAM'S INIT ROUTINE
;
T$ECONT:
	CALL	INIT	; PROG INIT ROUTINE
;
;  EXTRACT FLAGS IF PRESENT
;
	LXI	H,0	; SET FILE COUNT
	SHLD	V$FILECNT
	LHLD	V$CMDLNE	; PT TO BUFFER
;
;  SKIP TO FILE NAME STRING
;
	CALL	T$SBLANK	; SKIP OVER BLANKS
;
;  SKIP TO END OF FILE NAME STRING
;
	CALL	T$SNBLANK	; SKIP OVER NON-BLANKS
;
;  CHECK FOR LEADING SLASH ON OPTION AND SKIP IT IF SO
;
T$OPT:
	CPI	'/'	; OPTION CHAR?
	JNZ	T$OPTION
	INX	H	; SKIP SLASH
;
;  PROCESS LIST OF OPTIONS
;
T$OPTION:
	MOV	A,M	; GET BYTE
	ORA	A	; DONE?
	JZ	T$DSPEC
	INX	H	; PT TO NEXT CHAR
	CPI	' '	; SKIP OVER SPACES
	JZ	T$OPTION
	MOV	C,A	; COMMAND IN C
	LXI	D,OPTAB	; PT TO OPTION TABLE
T$OPTL:
	LDAX	D	; GET OPTION LETTER
	ORA	A	; END OF TABLE?
	JZ	T$HELPENT	; HELP IF SO
	CMP	C	; MATCH?
	JZ	T$OPTM	; PROCESS IF SO
	INX	D	; PT TO NEXT ENTRY
	INX	D
	INX	D
	JMP	T$OPTL
;
;  PROCESS OPTION
;
T$OPTM:
	PUSH	H	; SAVE HL ON STACK
	LXI	H,T$OPTION	; GET RETURN ADDRESS
	XTHL		; ... ON STACK AND RESTORE HL
	INX	D	; PT TO ADDRESS
	LDAX	D	; GET ADDRESS LOW
	MOV	B,A	; ... IN B
	INX	D
	LDAX	D	; GET ADDRESS HIGH
	MOV	D,A	; ... IN D
	MOV	E,B	; LOW IN E
	PUSH	D	; PUT ADDRESS ON STACK
	MOV	A,C	; COMMAND IN A
	RET		; "CALL" OPTION ROUTINE
;
;  BEGIN MOVING THROUGH FILE NAMES, SEPARATED BY COMMAS
;
T$DSPEC:
	LHLD	V$CMDLNE	; PT TO FIRST BYTE
	CALL	T$SBLANK	; SKIP TO NON-BLANK
;
;  MAJOR REENTRY POINT WHEN FILE SPECS ARE SEPARATED BY COMMAS
;    HL PTS TO FIRST BYTE OF NEXT FILE SPEC
;
T$DSPEC1:
	LXI	SP,V$STACK	; RESET STACK
	CALL	GETUD	; RESET USER IF NECESSARY
	LXI	D,V$NTFCB	; PT TO FCB IN DE, PT TO 1ST CHAR OF FN IN HL

	CALL	ZFNAME	; EXTRACT FILE NAME INTO FCB, AND GET DISK AND USER
	JZ	T$DERR	; ERROR HANDLER

	SHLD	V$NEXTCH	; SAVE PTR TO DELIMITER WHICH ENDED SCAN
	MOV	A,B	; SAVE POSSIBLE DRIVE SPEC
	CPI	0FFH	; CURRENT DISK?
	JZ	T$DSPEC2
	LDA	MDISK	; GET MAX DISK NUMBER
	DCR	B	; ADJUST TO WITHIN BOUNDS 0-15
	CMP	B	; WITHIN BOUNDS?
	MOV	A,B	; GET DISK NUMBER IN A
	JNC	T$USPEC
T$DERR:
	CALL	PRINT
	DB	CR,LF,'Invalid Disk Specification',0
	JMP	T$RETURN

;
;  SET CURRENT DISK
;
T$DSPEC2:
	LDA	V$DISK	;GET CURRENT DISK
	MOV	B,A	;... IN B

;  CHECK FOR USER NUMBER
T$USPEC:
	MOV	A,C	; GET NEW USER NUMBER
	CPI	0FFH	; DEFAULT USER?
	JZ	T$USPEC1
	CPI	'?'	; ALL USERS NOT ALLOWED?
	JZ	T$UERR
	LDA	MUSER	; GET MAX USER NUMBER
	CMP	C
	MOV	A,C	; USER NUMBER IN A
	JNC	T$FCT
T$UERR:
	CALL	PRINT
	DB	CR,LF,'Invalid User Number',0
	JMP	T$RETURN
T$USPEC1:
	LDA	V$USER	;GET CURRENT USER
	MOV	C,A	;... IN C

;
;  LOAD DIRECTORY AND PERFORM FUNCTION
;
T$FCT:
	MOV	A,B	; SAVE NEW DISK/USER AWAY
	STA	V$CDISK	; CURRENT DISK
	MOV	A,C
	STA	V$CUSER	; CURRENT USER
	CALL	LOGUD	; LOG INTO ACCOUNT
	CALL	CODEND	; PT TO END OF CODE
	CALL	RETUD	; GET USER NUMBER FOR DIRFS
	MVI	A,11000000B	; SELECT SYS AND NON-SYS FILES
	ORA	C	; OR IN USER NUMBER
	LXI	D,V$NTFCB	; PT TO FCB
	CALL	INITFCB	; INIT THE FCB
	CALL	DIRFS	; LOAD DIR, SELECT FILES, PACK, AND ALPHABETIZE
;
;  DETERMINE BEGINNING OF SCRATCH AREA (SCRATCH) AND SIZE IN PAGES (BCNT)
;
	PUSH	H	; SAVE PTR AND COUNT
	PUSH	B
	LXI	D,C$ESIZE	; SET PTR TO NEXT FREE BLOCK
T$FCTFRE:
	MOV	A,B	; DONE?
	ORA	C
	JZ	T$FCTFR1
	DAD	D	; PT TO NEXT
	DCX	B	; COUNT DOWN
	JMP	T$FCTFRE
T$FCTFR1:
	INR	H	; NEXT PAGE
	MVI	L,0
	SHLD	V$SCRATCH	; SET PTR TO SCRATCH AREA
	XCHG		; PTR IN DE
	LHLD	BDOSE+1	; COMPUTE BLOCK BUFFER SIZE
	MOV	A,H	; ADJUST FOR ZCPR2
	SUI	10
	SUB	D	; A=SIZE IN BLOCKS
	STA	V$BCNT	; SET BLOCK COUNT
	POP	B	; RESTORE AND SAVE REGS
	POP	H
;
;  ALLOW USER TO INSPECT FILES
;
	PUSH	H
	PUSH	B
	CALL	T$ICHECK	; CHECK FOR INSPECT OPTION AND INSPECT IF SET
	POP	B	; RESTORE COUNT AND PTR
	POP	H

;
;  PERFORM FUNCTION; HL PTS TO FILE AND BC CONTAINS NUMBER OF FILES
;
T$FCTL:
	MOV	A,B		; CHECK FOR COMPLETION (COUNT = 0)
	ORA	C
	JZ	T$FCTL1
	DCX	B		; COUNT DOWN
	LXI	SP,V$STACK	; RESET STACK
	PUSH	B		; SAVE COUNT AND PTR
	PUSH	H
	MOV	A,M		; SELECTED FILE?
	ORA	A		; 0=YES
	CZ	FUNCTION	; PERFORM FUNCTION
;
;  ENTRY POINT TO SKIP TO NEXT FILE IN LIST
;
E$FCTLNXT:
	LXI	SP,V$STACK-4	; RESTORE STACK
	POP	H		; RESTORE PTR
	POP	B		; RESTORE COUNT
	LXI	D,C$ESIZE	; PT TO NEXT ENTRY
	DAD	D
	JMP	T$FCTL

;
;  CHECK FOR NEXT FILE SPEC
;
T$FCTL1:
	CALL	GETUD	; RETURN TO BASE USER/DISK
	LHLD	V$NEXTCH	; GET PTR
	MOV	A,M	; GET DELIM
	CPI	','	; ANOTHER FILE?
	JNZ	T$RETURN
	INX	H	; PT TO CHAR AFTER COMMA
	JMP	T$DSPEC1	; CONTINUE PROCESSING
;
;  INSPECT FILES -- THIS ROUTINE IS TO PERFORM A FILE INSPECTION
;	ON INPUT, HL PTS TO FIRST 16-BYTE ENTRY AND BC=NUMBER OF ENTRIES
;
T$ICHECK:
	MOV	A,B	;ANY FILES?
	ORA	C	;0=NO
	RZ
	PUSH	H	;SAVE PTRS
	PUSH	B
	LXI	D,C$ESIZE	;SIZE OF ENTRY
T$ICHK1:
	MVI	M,0	;CLEAR MSBYTES
	DAD	D	;PT TO NEXT
	DCX	B	;COUNT DOWN
	MOV	A,B	;DONE?
	ORA	C
	JNZ	T$ICHK1
	POP	B	;RESTORE PTRS
	POP	H
	LDA	V$INSPECT	;INSPECT?
	ORA	A	;0=NO
	RZ
	CALL	PRINT
	DB	CR,LF,'File Inspect Mode',0
T$ICHK2:
	CALL	PRINT
	DB	CR,LF,'Select ',0
	CALL	E$PRFN	;PRINT FILE NAME
	CALL	PRINT
	DB	' -- (Y/N/Q=Select Rest/S=Skip Rest/other=Y)? '
	DB	0
	CALL	CIN	;GET RESPONSE
	CALL	CAPS	;CAPITALIZE
	CALL	COUT	;ECHO
	CPI	'Q'	;SELECT REST?
	JZ	T$ICHKYR
	CPI	'S'	;SKIP REST
	JZ	T$ICHKNR
	CPI	'N'	;NO TO THIS ONE?
	JNZ	T$ICHK3
	MVI	M,0FFH	;SET NO FLAG IN FILE FCB
T$ICHK3:
	DAD	D	;PT TO NEXT ONE
	DCX	B	;COUNT DOWN
	MOV	A,B	;DONE?
	ORA	C
	JNZ	T$ICHK2
	RET
;  CHECK REST OF FILES AS SELECTED
T$ICHKYR:
	CALL	PRINT
	DB	CR,LF,'	Rest of Files Selected',0
	RET
;  CHECK REST OF FILES AS NOT SELECTED
T$ICHKNR:
	MVI	M,0FFH	;SET NO FLAG
	DAD	D	;PT TO NEXT
	DCX	B	;COUNT DOWN
	MOV	A,B	;DONE?
	ORA	C
	JNZ	T$ICHKNR
	CALL	PRINT
	DB	CR,LF,'	Rest of Files NOT Selected',0
	RET
;
;  UTILITIES
;	T$SBLANK  -- SKIP BLANKS PTED TO BY HL UNTIL NON-BLANK ENCOUNTERED; HL
;	T$SNBLANK -- SKIP NON-BLANKS PTED TO BY HL UNTIL BLANK OR EOL; HL
;	E$PRFN    -- PRINT FILE NAME PTED TO BY HL; AFFECT NOTHING

;
;  SKIP UNTIL NON-BLANK
;
T$SBLANK:
	MOV	A,M	; LOOK FOR BLANK
	INX	H	; PT TO NEXT
	CPI	' '	; BLANK?
	JZ	T$SBLANK
	DCX	H	; BACK UP
	RET

;
;  SKIP UNTIL BLANK OR EOL
;
T$SNBLANK:
	MOV	A,M	; GET CHAR
	INX	H	; PT TO NEXT
	CPI	' '	; BLANK?
	JZ	T$SNB1
	ORA	A	; EOL?
	JNZ	T$SNBLANK
T$SNB1:
	DCX	H	; BACK UP
	RET

;
;  PRINT FILE NAME PTED TO BY HL
;	OUTPUT TO CON:
;
E$PRFN:
	PUSH	H	; SAVE REGS
	PUSH	B
	CALL	RETUD	; GET CURRENT USER/DISK
	MOV	A,B	; GET DISK NUMBER
	ADI	'A'	; CONVERT TO LETTER
	CALL	COUT	; PRINT LETTER
	MOV	A,C	; GET USER NUMBER
	CALL	PADC	; PRINT USER NUMBER
	CALL	PRINT
	DB	': ',0
	INX	H	; PT TO FILE NAME
	MVI	B,8	; PRINT NAME
	CALL	T$PRNT
	MVI	A,'.'	; DECIMAL
	CALL	COUT
	MVI	B,3	; PRINT TYPE
	CALL	T$PRNT
	POP	B	; GET REGS
	POP	H
	RET

;
;  PRINT CHARS PTED TO BY HL FOR B BYTES
;	OUTPUT TO CON:
;
T$PRNT:
	MOV	A,M	; GET CHAR
	CALL	COUT
	INX	H	; PT TO NEXT
	DCR	B	; COUNT DOWN
	JNZ	T$PRNT
	RET

;***********************************************
;*  Application-Specific Section
;***********************************************

;****************************************************
;*
;*  Function-Specific Routines
;*	These routines need to be customized for the
;* specific function being performed.  These, in
;* effect, implement the function.  Other Entry Points
;* useful to the programmer are:
;*		E$FCTLNXT -- Clean Abort of Current
;*				Processing and Skip
;*				to Next File in List;
;*				This is a Clean Way to
;*				Abort FUNCTION for the
;*				Next File
;*		E$PRFN    -- Print File Name Pted to
;*				by HL; No Regs Affected
;*
;****************************************************

;
;  **** EMERGENCY ABORT
;
ABORT:
	CALL	PRINT
	db	'<< Insert Your Abort Message Here >>'
	DB	0
	CALL	GETUD	; RETURN HOME
	JMP	T$RETURN
;
;  **** BANNER -- PRINT BANNER FOR PROGRAM (PROGRAM NAME ET AL)
;
BANNER:
	CALL	PRINT
	db	'<< Insert Banner of Program Here >>'
	DB	0
	RET
;
;  **** HELP -- PRINT PROGRAM'S HELP MESSAGE
;
HELP:
	CALL	PRINT
	db	'<< Insert HELP Text Here >>'
	DB	0
	RET
;
;  **** PROGRAM INIT ROUTINE
;	THIS ROUTINE IS USED BY THE PROGRAM TO PERFORM ANY NECESSARY
;	INITIALIZATIONS
;
INIT:
	RET
;
;  **** FUNCTION COMPLETE -- CLEANUP AND EXIT
;	FILL THIS IN WITH CLEANUP CODE FOR EXIT
;
DINIT:
	RET
;
;  **** OPTION TABLE USED TO PROCESS COMMAND LINE
;	EACH OPTION IS A CAPITAL LETTER OR SPECIAL CHAR FOLLOWED BY
;		AN ADDRESS; THE TABLE IS TERMINATED BY A BINARY ZERO
;
OPTAB:
	DB	'I'	; FILE INSPECTION OPTION
	DW	OPTINSP	; REMOVE THESE TWO LINES AND THE FOLLOWING ROUTINE
			;   IF YOU DO NOT WANT FILE INSPECTION OPTION IN
			;   COMMAND LINE
	DB	0	; END OF TABLE
;
;  **** OPTION ROUTINES
;	EACH ROUTINE IS PROVIDED THE OPTION CHARACTER IN THE A REGISTER
;	AND A POINTER TO THE NEXT CHARACTER IN THE COMMAND LINE IN THE
;	HL REGISTER PAIR; ONLY HL NEED TO BE PRESERVED (WITH OPTIONAL
;	ADVANCEMENT TO THE NEXT OPTION) ON EXIT
;
OPTINSP:
	MVI	A,0FFH	; TURN ON FILE INSPECTION OPTION
	STA	V$INSPECT	; THIS IS PROVIDED AS A SAMPLE ROUTINE
				;   AND FOR THE INDICATED FUNCTION
	RET
;
;  **** FUNCTION -- MAIN FUNCTION OF TEMPLATE
;	ON ENTRY, HL PTS TO NAME OF FILE (16 BYTES) AND USER IS LOGGED INTO
;		DIRECTORY CONTAINING INDICATED FILE
;
FUNCTION:
	CALL	CRLF
	CALL	E$PRFN	; THIS IS PROVIDED AS A SIMPLE ROUTINE TO RUN
	RET
;
;  **** BUFFERS -- PLACE APPLICATION-SPECIFIC BUFFERS HERE
;

;***********************************************
;*  End of Application-Specific Section
;***********************************************

;
;  BUFFERS
;
V$DISK:
	DS	1	; HOME DISK NUMBER
V$USER:
	DS	1	; HOME USER NUMBER
V$CDISK:
	DS	1	; CURRENT DISK NUMBER
V$CUSER:
	DS	1	; CURRENT USER NUMBER
V$CMDLNE:
	DS	2	; PTR TO COMMAND LINE STRING
V$NEXTCH:
	DS	2	; PTR TO NEXT CHAR IN MULTIFILE COMMAND LINE
V$FILECNT:
	DS	2	; COUNT OF NUMBER OF FILES RENAMED
V$SCRATCH:
	DS	2	; ADDRESS OF FIRST BYTE OF SCRATCH AREA
V$BCNT:
	DS	1	; NUMBER OF PAGES IN SCRATCH AREA
V$INSPECT:
	DS	1	; INSPECT FLAG
V$NTFCB:
	DS	36	; FCB FOR NEW FILE
;
;  Stack
;
	DS	100	; STACK AREA
V$STACK:
	DS	2	; OLD STACK PTR

	END
