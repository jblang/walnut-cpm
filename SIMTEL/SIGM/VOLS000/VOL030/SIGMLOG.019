Sig/M volume 19		miscellaneous Pascal Z programs

	(original materials from Pascal Z User Group volume 1)

	-CATALOG.019		contents of Sig/M volume 19
	-CATALOG.ACK		acknowledgement file
	ABSTRACT.019		comments file
	CRCKFILE.019		CRC of volume 19

19.1	AUTOBOOT.ASM	 5K	autoboot on CP/M cold start
19.2	AUTOBOOT.COM	 1K	/
19.3	LINEARP.PAS	11K	simplex algorithm to minimize
19.4	LINEARP.COM	21K		a cost function to constraints
19.5	VARIANT.PAS	 1K	demo for variant records
19.6	VARIANT.COM	 5K	/
19.7	REVERSE.PAS	 2K	demo for linked lists
19.8	REVERSE.COM	 6K	/
19.9	EDITFILE.PAS	 9K	adapted from S-100 Microsystems
19.10	EDITFILE.COM	13K	/
19.11	RT.PAS		 4K	demo program for non-text files
19.12	RT.COM		 8K	/
19.13	STARS.PAS	 6K	game
19.14	STARS.COM	 7K	/
19.15	ADDN.PAS	 1K	simple demo to add two numbers
19.16	ADDN.COM	 6K	/
19.17	ZMNEMONS.DOC	13K	programming aid
19.18	TRIAN.PAS	 1K	demo on FOR loops
19.19	TRIAN.COM	 4K	/
19.20	CONCHAR.PAS	 6K	utility for command line input
19.21	SCAN2X.PAS	 5K	file READ evaluation
19.22	SCAN2X.COM	 8K	/
19.23	STRDEMO.PAS	14K	demo on string functions
19.24	STRLIB.DOC	 4K	part of STRDEMO.PAS
19.25	LONG.PAS	 3K	demo to string words together
19.26	LONG.COM	 7K	/
19.27	MAKEREL.DOC	 8K	convert REL. files from function blks
19.28	LIOS.ASM	 7K	novice utility
19.29	CONVERT.PAS	 1K	convert gas in liters
19.30	CONVERT.COM	 6K	/
19.31	COMPARE.!!!	11K	compare source code files from UCSD
19.32	DUMP.ASM	23K	expanded CP/M DUMP program
19.33	LSTR.PAS	 2K	generates a line of various length 


ThÂ Sig/Õ UseÚ Grou receive‰ thÂ PascaÏ ⁄ UseÚ Grou volumeÛ foÚ ç
inclusioÓ intÔ thÂ libraryÆ† WÂ thanÎ CharliÂ FosteÚ whÔ ha‰ donÂ ç
thÂ† originaÏ compilatioÓ foÚ hiÛ contributioÓ an‰† effortsÆ† ThÂ ç
PascaÏ† ⁄† UseÚ Grou librarieÛ arÂ no˜ parÙ oÊ Sig/Õ volumeÛ† 1π ç
througË 25.

    


                         Z-userÛ group
                          VolumÂ #1

     SincÂ thiÛ iÛ thÂ ver˘ firsÙ disÎ distribute‰ b˘ thÂ Z-userÛ 
group¨  iÙ  seemÛ appropriatÂ thaÙ … givÂ yoı · littlÂ histor˘ oÊ 
jusÙ ho˜ thiÛ alÏ startedÆ  

     WheÓ … starte‰ iÓ thÂ MicrocomputeÚ arena¨ twÔ yearÛ agoÆ  … 
didn'Ù  kno˜  anythinÁ abouÙ anythingÆ   BuÙ …  aÌ  ·  compulsivÂ 
readeÚ an‰ spenÙ much¨  mucË timÂ readinÁ whaÙ thÂ expertÛ ha‰ tÔ 
sayÆ   …  theÓ tooÎ theiÚ advice¨  pocketbooÎ  permittingÆ   ThaÙ 
meanÙ  thaÙ  …  waÛ goinÁ tÔ havÂ ·  S-10∞  bus¨  Z-80¨  duaÏ  8¢ 
floppies¨†  64Î†  oÊ  memory¨† alÏ  runninÁ  undeÚ†  CPMÆ†   TheÓ  ç
camÂ† languagesÆ††   AÙ†  first¨††  …† wenÙ† alonÁ† witË†  BasicÆ   ç
However¨†  iÙ† didn'Ù† reall˘ turÓ mÂ oÓ sÔ … jusÙ collecte‰† an‰ ç
drifte‰† froÌ† onÂ languagÂ tÔ anotherÆ†   ThÂ expertÛ† sai‰† thÂ ç
greatesÙ thinÁ aroun‰ waÛ  PascalÆ†   SÔ  wheÓ  UCSƒ  PascaÏ† waÛ ç
offere‰†  tÔ†  ouÚ†  locaÏ ComputeÚ clu‚ … chippe‰ iÓ an‰† goÙ† · ç
copyÆ†   OuÙ oÊ fort˘ memberÛ whÔ  goÙ  thaÙ Pascal¨†  onl˘ threÂ ç
oÊ uÛ goÙ iÙ u  an‰  runningÆ  NonÂ  oÊ  uÛ use‰ iÙ AFTE“ wÂ goÙ ç
iÙ†  u†  an‰†  runningÆ†   Mostly¨† becausÂ  wÂ†  werÂ† alÏ† CPÕ ç
orientatedÆ   SÔ wÂ gavÂ u oÓ  PascalÆ  Meanwhile¨ … waÛ stayinÁ ç
iÓ toucË witË variouÛ friendÛ aroun‰ thÂ countr˘ an‰ onÂ oÊ† theÌ ç
tol‰† mÂ abouÙ Ithaca'Û PASCAL/ZÆ†   IÙ waÛ onl˘ versioÓ #± buÙ … ç
love‰ iÙ froÌ thÂ ver˘ firstÆ   … like‰ thÂ  ide· an‰ iÓ spitÂ oÊ ç
thÂ earl˘ bugs¨†  … ha‰ · balÏ witË  itÆ  SÔ … boughÙ versioÓ 2.∞ ç
an‰ like‰ thaÙ eveÓ better.

     Man˘ programÛ lateÚ … waÛ · confirme‰ PascaÏ freakÆ  SÔ mucË 
sÔ  thaÙ  wheÓ  thÂ  S∆ FaiÚ rolle‰ around¨  …  looke‰  u  StevÂ 
EdlemanÆ  HÂ waÛ thÂ guidinÁ lighÙ foÚ Ithac· IntersystemÛ an‰ wÂ 
seeme‰  tÔ havÂ somÂ commoÓ interestsÆ   TÔ makÂ ·  shorÙ  story¨ 
shorter¨  StevÂ  tooÎ · couplÂ oÊ m˘ suggestionÛ tÔ hearÙ an‰  iÓ 
Ma˘ oÊ 198∞ announce‰ tÔ thÂ worl‰ thaÙ Ithac· IntersystemÛ woul‰ 
activel˘  supporÙ · Pascal/⁄ useÚ groupÆ   … offere‰ tÔ direcÙ iÙ 
an‰ kee iÙ running¨ sÔ wÂ madÂ · deal.

     ThÂ  intenÙ  oÊ thiÛ grou iÛ tÔ assisÙ  Pascal/Z¨  Z8∞  an‰ 
Z800∞  softwarÂ  disseminationÆ   ThaÙ way¨  we'lÏ alÏ  geÙ  morÂ 
programÛ tÔ pla˘ aroun‰ witË an‰ havÂ fuÓ too.

     FoÚ thÂ stranger¨ whÔ happenÛ tÔ picÎ u thiÛ disk¨ Pascal/⁄ 
requireÛ  ·  Z8∞  cpu¨  CPÕ an‰  56Î  oÊ  useablÂ  memoryÆ   MosÙ 
everythinÁ  elsÂ iÛ u tÔ thÂ owneÚ oÊ thÂ systemÆ   … inten‰  tÔ 
publisË  ·  flyeÚ  bimonthl˘ sÔ thÂ bugs¨  fixeÛ  an‰  an˘  otheÚ 
interestinÁ  itemÛ  caÓ bÂ passe‰ onÆ   DonationÛ  arÂ  certainl˘ 
neededÆ   … wilÏ tr˘ tÔ ediÙ an‰ tesÙ alÏ programÛ sent¨ givÂ thÂ 
authoÚ  plent˘  oÊ  crediÙ an‰ sprea‰ hiÛ prograÌ  alÏ  oveÚ  thÂ 
worldÆ   ItÛ  likÂ  · chaiÓ letter¨  yoı sen‰ iÓ one¨  an‰ geÙ  · 
hundre‰ backÆ   SÔ don'Ù bÂ lazy¨ sen‰ iÙ inÆ  Someone¨ somewherÂ 
wilÏ bÂ gla‰ yoı didÆ  An‰ yoı wilÏ too.
.paäCHARLI≈ FOSTER
Director
Z-Users Group
7962 Center Pkwy
Sacramento, Ca 95823


---------------------------------------------------------
-							-
-   Steps to make your Pascal procedure/function into a	-
-   .REL file so it may be included into a library of	-
-   commonly used routines.				-
---------------------------------------------------------


1.	Write your function/procedure and test it in a complete
	program.  When you are happy with your function then
	write up a dummy Pascal program. It will look something
	like this:

	Program dummy;
	type	new : (xxx,yyy);
	var	str8 : STRING 8;

	(*$I+	[include Pascal prgm stmts]	*)
	FUNCTION DOESITALL;
	begin
	...main body of function
	end(*---of does it all---*);

	(*---dummy program---*)
	begin end.


2.	-Notice the compiler option -   $I+
	 This is a must so you can see where the assembly source
	 program starts and ends.
	-You may include types and variables in the program heading
	 to get your function/procedure to compile but notice that
	 there is NO main program.

3	Compile the program with the Pascal compiler producing
	DOESITALL.SRC.

4.	Edit DOESITALL.SRC to include the following:

	a. The name of the routine:
		NAME DOESITALL

	b. The entry name for the linker:
		ENTRY DOESITALL

	c. The entry name as a label for the assembler:
		DOESITALL:


5.	All together it will look somwthing like this:


	;FUNCTION DOESITALL;		<---all Pascal source statements
	;				    will be included as comments
	;				    in your source program.
		NAME DOESITALL		<---These are the 3 statements
		ENTRY DOESITALL		    that you added
	DOESITALL:
		ENTR	D,2,0		<---this is the first line of the
					    source program
		---the rest of the source program
		   continues here---

	;end(*---of does it all---*);	<---this is the last line of
		EXIT	D,0		    your function and this is
					    the last line of the assembly
					    source.
	--------------------------------
	Anything after the EXIT statement is to be deleted.


6.	You are now ready to assemble the source program and make
	a .REL file.
	<first rename EMAIN.SRC to MACRO.SRC and in addition
	 edit EMAIN.SRC and remove the NAME statement from it.
	 We only want the names that we give to our routines
	 in the source code>

	ASMBL MACRO,DOESITALL/REL

	-This will produce DOESITALL.REL

7.	DOESITALL.REL is now ready to be included in your library:

	LINK /L:B:ALLOFIT B:DOESITALL /E

	-This will create a library named ALLOFIT.REL

8.	We now write a program that calls DOESITALL.
	It is not until link time that there is any need for the
	routine at all.

	LINK /N:B:SUPERWRITER B:SUPERWRITER A:ALLOFIT/S /E

	-Did you get all of that?
	a. We opened a .COM file on drive B: named SUPERWRITER.COM
	b. We opened a .REL file on drive B: named SUPERWRITER.REL
	c. We will search a library file named ALLOFIT.REL on drive A:
	d. And then exit to the CP/M operating system, searching
	   a file named LIB.REL to resolve any unresolved symbols.
	<<CP/M limits file names to 8 characters so please forgive
	  me when I get carried away>>

9.	Following is a Pascal program called RANDOM.PAS. that has
	been compiled and converted into a .REL file.  Look it over
	and see if you can do it also.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



(*$I+	[include Pascal prgm stmts]	*)
PROGRAM RANDOM;
VAR
  SEED1, SEED2 : INTEGER;
(*
==============================================
 PROGRAM TITLE:	RANDOM_NUMB_GENERATOR

 WRITTEN BY:	Raymond E. Penley
 DATE WRITTEN:	SEP 1979

 WRITTEN FOR:	Use with PASCAL/Z

 SUMMARY:
	Implement a Fibonacci series Random number generator.
	RANDOM will return numbers from 0 to 32767
	Call RANDOM with the following convention:
	 Range		 Use
	  0 - 32	RANDOM DIV 1000
	  0 - 327	RANDOM DIV 100
          0 - 32767	RANDOM
**
  Add these lines to your PASCAL source program:

    VAR  SEED1, SEED2 : INTEGER;

    PROCEDURE SEEDRAND; EXTERNAL;
    FUNCTION RANDOM: INTEGER; EXTERNAL;


  Also within the body of the main program
  but BEFORE calling RANDOM:

	  SEEDRAND;

==============================================
*)

PROCEDURE SEEDRAND;
(* INITIAL VALUES FOR SEED1 AND SEED2 ARE HERE  *)
(*
	NAME RANDOM			<<< these statements were included
	ENTRY SEEDRAND,RANDOM		<<< by me to make it easy to edit
					<<< the source code.
SEEDRAND:				<<< the LABEL goes directly in front
*)					<<< of the first BEGIN stmt
Begin
   SEED1 := 10946;
   SEED2 := 17711
END;


FUNCTION RANDOM : INTEGER;
(*
GLOBAL
  SEED1, SEED2 : INTEGER		*)
CONST
  HALFINT = 16383; (* 1/2 OF MAXINT *)
VAR
  temp1, temp2, HALF_ADDER : INTEGER;
(*
RANDOM:					<<< the LABEL goes directly in
*)					<<< front of the first BEGIN stmt
Begin
(* Take 1/2 of the seeds for the comparison test *)
  temp1 := SEED1 DIV 2;
  temp2 := SEED2 DIV 2;
  IF (temp1+temp2) >= HALFINT THEN
    (* the number is too big - scale it down *)
    HALF_ADDER := temp1 + temp2 - HALFINT
  ELSE
    HALF_ADDER := temp1 + temp2;
  SEED1 := SEED2;
  (* Restore from previous DIVision *)
  SEED2 := HALF_ADDER * 2;
  RANDOM := SEED2
END(*---RANDOM---*);

(*-----------DUMMY PROGRAM--------------*)
(* THIS MUST BE REMOVED VIA YOUR EDITOR *)
BEGIN END.




+++++++++++++++++++++++++++++++++++++++++++++++++++++++


	The assembler source code follows
	There has been some editing of the code
	to remove unwanted labels and program
	statements.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++






; ==============================================
;  PROGRAM TITLE:	RANDOM_NUMB_GENERATOR
; 
;  WRITTEN BY:          Raymond E. Penley
;  DATE WRITTEN:	SEP 1979
; 
;  WRITTEN FOR:	Use with PASCAL/Z
; 
;  SUMMARY:
; 	Implement a Fibonacci series Random number generator.
; 	RANDOM will return numbers from 0 to 32767
; 	Call RANDOM with the following convention:
; 	 Range		 Use
; 	  0 - 32	RANDOM DIV 1000
; 	  0 - 327	RANDOM DIV 100
;         0 - 32767	RANDOM
;
; Add these lines to your PASCAL source program:
; 
;     VAR  SEED1, SEED2 : INTEGER;
;
;     PROCEDURE SEEDRAND; EXTERNAL;
;     FUNCTION RANDOM: INTEGER; EXTERNAL;
; 
;
;     Also within the body of the main program
;     but BEFORE calling RANDOM:
;
;	  SEEDRAND;
;
;==============================================
;
	NAME	RANDOM
;
 	ENTRY SEEDRAND,RANDOM
;
;PROCEDURE SEEDRAND;
; INITIAL VALUES OF SEED1 AND SEED2 ARE HERE
; 
SEEDRAND:
	ENTR	D,2,0
;    SEED1 := 10946;
	MVI	0(IY),42
	MVI	-1(IY),194
;    SEED2 := 17711
	MVI	-2(IY),69
	MVI	-3(IY),47
; END;
	EXIT	D,0
;
;
; 
; FUNCTION RANDOM : INTEGER;
; GLOBAL
;   SEED1, SEED2 : INTEGER
; CONST
;   HALFINT = 16383; (* 1/2 OF MAXINT *)
; VAR
;   temp1, temp2, HALF_ADDER : INTEGER;
;
RANDOM:
	ENTR	D,2,6
; (* Take 1/2 of the seeds for the comparison test *)
;   temp1 := SEED1 DIV 2;
	MOV	L,-1(IY)
	MOV	H,0(IY)
	LXI	D,2
	DIVD	D,0
	MOV	-2(IX),H
	MOV	-3(IX),L
;   temp2 := SEED2 DIV 2;
	MOV	L,-3(IY)
	MOV	H,-2(IY)
	LXI	D,2
	DIVD	D,0
	MOV	-4(IX),H
	MOV	-5(IX),L
;   IF (temp1+temp2) >= HALFINT THEN
	MOV	L,-3(IX)
	MOV	H,-2(IX)
	MOV	E,-5(IX)
	MOV	D,-4(IX)
	DADD	D,0
	LXI	D,16383
	GE	D,0
;     (* the number is too big - scale it down *)
;     HALF_ADDER := temp1 + temp2 - HALFINT
	JNC	L171
	MOV	L,-3(IX)
	MOV	H,-2(IX)
	MOV	E,-5(IX)
	MOV	D,-4(IX)
	DADD	D,0
;   ELSE
	LXI	D,-16383
	DADD	D,0
	MOV	0(IX),H
	MOV	-1(IX),L
;     HALF_ADDER := temp1 + temp2;
	JMP	L191
L171
	MOV	L,-3(IX)
	MOV	H,-2(IX)
	MOV	E,-5(IX)
	MOV	D,-4(IX)
	DADD	D,0
	MOV	0(IX),H
	MOV	-1(IX),L
L191
;   SEED1 := SEED2;
	MOV	L,-3(IY)
	MOV	H,-2(IY)
	MOV	0(IY),H
	MOV	-1(IY),L
;   (* Restore from previous DIVision *)
;   SEED2 := HALF_ADDER * 2;
	MOV	L,-1(IX)
	MOV	H,0(IX)
	DADD	C
	MOV	-2(IY),H
	MOV	-3(IY),L
;   RANDOM := SEED2
	MOV	L,-3(IY)
	MOV	H,-2(IY)
	MOV	3(IX),H
	MOV	2(IX),L
; END(*---RANDOM---*);
	EXIT	D,0



+++++++++++++++++++++++++++++++++++++++++++++++++++++


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:          Cross Reference listing of Z-80 Mnemonics      
:
:Courtesy of Tim Eliseo
:		%PCE, 4778 Dewey Dr, Fair Oaks, Ca 95628
:June 1980
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

     This  document is a cross-reference listing of the  standard 
Zilog Z-80 mnemonics to the bastardized TDL Z-80 mnemonics.   The 
TDL  mnemonics  are upward compatible to the standard Intel  8080 
mnemonics,  making  it  easy  to  upgrade  existing  8080  source 
programs to the Z-80 CPU.  The only problem is that they are just 
as illogical as the original 8080 mnemonics, and there is no real 
standard for them.   These are the mnemonics which are used  with 
PASCAL/Z  and the assembler that comes with the  package.   These 
tables   will  make  it  easy  for  the  Z-80  assembly  language 
programmer to cross reference the non-standard mnemonics.
     If an asterisk appears in the left-hand column of a line, it 
means that all of the instructions specified in that line, except 
those that refer to the Z-80 index registers, are compatible with 
the 8080.
     There   are   a  few  instructions  that   require   further 
clarification.  The TDL assembler mnemonics JV, JNV, CV, CNV, RV, 
and RNV are synonymous to the 8080 mnemonics JPE,  JPO, CPE, CPO, 
RPE,  and  RPO  respectively.   These instructions refer  to  the 
parity/overflow  flag in the Z-80 when it is used as an  overflow 
flag  and  are not included in 8080 assemblers,  even though  the 
instructions  will execute on the 8080 but will always  refer  to 
the  flag as a parity flag (this flag is always a parity flag  in 
the 8080).
     Another  instruction which requires clarification is the RST 
instruction.   In the TDL assembler the operand is a number which 
is actually the restart address divided by 8,  while in the Zilog 
assembler the operand is the actual restart address.
     Following  is a list of the abbreviations that are  used  to 
reference a group of similar operands.   Notice that although the 
same  symbol may be used as an operand for both a Zilog  mnemonic 
and a TDL mnemonic that they may refer to different things.  When 
two  lists  are given in the following table,  one for the  Zilog 
assembler and one for the  Z  assembler,  you may assume that the 
items in each list parallel each other.


Symbol	Standard (Zilog) Z-80		Bastardized (TDL) Z-80

r	Register A,B,C,D,E,H, or L	Register A,B,C,D,E,H, or L
n	One byte value			One byte value
ii	Index register IX, IY		Index register X or IX, Y or IY
jj	rr or ii			rr or ii
d	8-bit index displacement	8-bit index displacement
zz	Register pair BC or DE		Register pair B or D
nn	Two byte (address) value	Two byte (address) value
rr	Register pair BC,DE,HL, or SP	Register pair B,D,H, or SP
qq	Register pair BC,DE,HL, or AF	Register pair B,D,H, or PSW
s	r, (HL), or (ii+d)		r, M, or d(ii)
tt	Register BC,DE,SP, or IX	Register B,D,SP, or X
uu	Register BC,DE,SP, or IY	Register B,D,SP, or Y
b	Bit number 0-7			Bit number 0-7
.PA

            Z-80 instructions arranged by group


8080?	Standard (Zilog) Z-80		Bastardized (TDL) Z-80


                      8 Bit load group

*	LD	r,s			MOV	r,s
*	LD	r,n			MVI	r,n
*	LD	s,r			MOV	s,r
*	LD	A,(nn)			LDA	nn
*	LD	(nn),A			STA	nn
*	LD	A,(zz)			LDAX	zz
*	LD	(zz),A			STAX	zz
	LD	A,I			LDAI
	LD	A,R			LDAR
	LD	I,A			STAI
	LD	R,A			STAR



                     16 Bit load group

*	LD	jj,nn			LXI	jj,nn
	LD	BC,(nn)			LBCD	nn
	LD	DE,(nn)			LDED	nn
*	LD	HL,(nn)			LHLD	nn
	LD	IX,(nn)			LIXD	nn
	LD	IY,(nn)			LIYD	nn
	LD	SP,(nn)			LSPD	nn
	LD	(nn),BC			SBCD	nn
	LD	(nn),DE			SDED	nn
*	LD	(nn),HL			SHLD	nn
	LD	(nn),IX			SIXD	nn
	LD	(nn),IY			SIYD	nn
	LD	(nn),SP			SSPD	nn
*	LD	SP,HL			SPHL
	LD	SP,IX			SPIX
	LD	SP,IY			SPIY
*	PUSH	qq			PUSH	qq
	PUSH	ii			PUSH	ii
*	POP	qq			POP	qq
	POP	ii			POP	ii



         Exchange, block transfer, and search group

*	EX	DE,HL			XCHG
	EX	AF,AF'			EXAF
	EXX				EXX
*	EX	(SP),HL			XTHL
	EX	(SP),IX			XTIX
	EX	(SP),IY			XTIY
	LDI				LDI
	LDIR				LDIR
	LDD				LDD
	LDDR				LDDR
	CPI				CCI
	CPIR				CCIR
	CPD				CCD
	CPDR				CCDR



             8 bit arithmetic and logical group

*	ADD	A,s			ADD	s
*	ADD	A,n			ADI	n
*	ADC	A,s			ADC	s
*	ADC	A,n			ACI	n
*	SUB	A,s			SUB	s
*	SUB	A,n			SUI	n
*	SBC	A,s			SBB	s
*	SBC	A,n			SBI	n
*	AND	A,s			ANA	s
*	AND	A,n			ANI	n
*	OR	A,s			ORA	s
*	OR	A,n			ORI	n
*	XOR	A,s			XRA	s
*	XOR	A,n			XRI	n
*	CP	A,s			CMP	s
*	CP	A,n			CPI	n
*	INC	s			INR	s
*	DEC	s			DCR	s



      General purpose arithmetic and CPU control group

*	DAA				DAA
*	CPL				CMA
	NEG				NEG
*	CCF				CMC
*	SCF				STC
*	NOP				NOP
*	HALT				HLT
*	DI				DI
*	EI				EI
	IM	0			IM0
	IM	1			IM1
	IM	2			IM2



                  16 bit arithmetic group

*	ADD	HL,rr			DAD	rr
	ADC	HL,rr			DADC	rr
	SBC	HL,rr			DSBC	rr
	ADD	IX,tt			DADX	tt
	ADD	IY,uu			DADY	uu
*	INC	jj			INX	jj
*	DEC	jj			DCX	jj



                   Rotate and shift group

*	RLCA				RLC
*	RLA				RAL
*	RRCA				RRC
*	RRA				RAR
	RLC	s			RLCR	s
	RL	s			RALR	s
	RRC	s			RRCR	s
	RR	s			RARR	s
	SLA	s			SLAR	s
	SRA	s			SRAR	s
	SRL	s			SRLR	s
	RLD				RLD
	RRD				RRD



               Bit set, reset, and test group

	BIT	b,s			BIT	b,s
	SET	b,s			BSET	b,s
	RES	b,s			RES	b,s



                         Jump group

*	JP	nn			JMP	nn
*	JP	Z,nn			JZ	nn
*	JP	NZ,nn			JNZ	nn
*	JP	C,nn			JC	nn
*	JP	NC,nn			JNC	nn
*	JP	PO,nn			JPO	nn
*	JP	PE,nn			JPE	nn
*	JP	P,nn			JP	nn
*	JP	M,nn			JM	nn
*	JP	PE,nn			JV	nn
*	JP	PO,nn			JNV	nn
	JR	nn			JMPR	nn
	JR	Z,nn			JRZ	nn
	JR	NZ,nn			JRNZ	nn
	JR	C,nn			JRC	nn
	JR	NC,nn			JRNC	nn
	DJNZ	nn			DJNZ	nn
*	JP	(HL)			PCHL
	JP	(IX)			PCIX
	JP	(IY)			PCIY



                   Call and return group

*	CALL	nn			CALL	nn
*	CALL	Z,nn			CZ	nn
*	CALL	NZ,nn			CNZ	nn
*	CALL	C,nn			CC	nn
*	CALL	NC,nn			CNC	nn
*	CALL	PO,nn			CPO	nn
*	CALL	PE,nn			CPE	nn
*	CALL	P,nn			CP	nn
*	CALL	M,nn			CM	nn
*	CALL	PE,nn			CV	nn
*	CALL	PO,nn			CNV	nn
*	RET				RET
*	RET	Z			RZ
*	RET	NZ			RNZ
*	RET	C			RC
*	RET	NC			RNC
*	RET	PO			RPO
*	RET	PE			RPE
*	RET	P			RP
*	RET	M			RM
*	RET	PE			RV
*	RET	PO			RNV
	RETI				RETI
	RETN				RETN
*	RST	n			RST	n/8



                   Input and output group

*	IN	A,(n)			IN	n
	IN	r,(C)			INP	r
	INI				INI
	INIR				INIR
	IND				IND
	INDR				INDR
*	OUT	(n),A			OUT	n
	OUT	(C),r			OUTP	r
	OUTI				OUTI
	OUTD				OUTD
	OTDR				OUTDR



    Z-80 instructions sorted by standard Zilog mnemonics


8080?	Standard (Zilog) Z-80		Bastardized (TDL) Z-80


*	ADC	A,n			ACI	n
*	ADC	A,s			ADC	s
	ADC	HL,rr			DADC	rr
*	ADD	A,n			ADI	n
*	ADD	A,s			ADD	s
*	ADD	HL,rr			DAD	rr
	ADD	IX,tt			DADX	tt
	ADD	IY,uu			DADY	uu
*	AND	A,n			ANI	n
*	AND	A,s			ANA	s
	BIT	b,s			BIT	b,s
*	CALL	C,nn			CC	nn
*	CALL	M,nn			CM	nn
*	CALL	NC,nn			CNC	nn
*	CALL	nn			CALL	nn
*	CALL	NZ,nn			CNZ	nn
*	CALL	P,nn			CP	nn
*	CALL	PE,nn			CPE	nn
*	CALL	PE,nn			CV	nn
*	CALL	PO,nn			CNV	nn
*	CALL	PO,nn			CPO	nn
*	CALL	Z,nn			CZ	nn
*	CCF				CMC
*	CP	A,n			CPI	n
*	CP	A,s			CMP	s
	CPD				CCD
	CPDR				CCDR
	CPI				CCI
	CPIR				CCIR
*	CPL				CMA
*	DAA				DAA
*	DEC	jj			DCX	jj
*	DEC	s			DCR	s
*	DI				DI
	DJNZ	nn			DJNZ	nn
*	EI				EI
*	EX	(SP),HL			XTHL
	EX	(SP),IX			XTIX
	EX	(SP),IY			XTIY
	EX	AF,AF'			EXAF
*	EX	DE,HL			XCHG
	EXX				EXX
*	HALT				HLT
	IM	0			IM0
	IM	1			IM1
	IM	2			IM2
*	IN	A,(n)			IN	n
	IN	r,(C)			INP	r
*	INC	jj			INX	jj
*	INC	s			INR	s
	IND				IND
	INDR				INDR
	INI				INI
	INIR				INIR
*	JP	(HL)			PCHL
	JP	(IX)			PCIX
	JP	(IY)			PCIY
*	JP	C,nn			JC	nn
*	JP	M,nn			JM	nn
*	JP	NC,nn			JNC	nn
*	JP	nn			JMP	nn
*	JP	NZ,nn			JNZ	nn
*	JP	P,nn			JP	nn
*	JP	PE,nn			JPE	nn
*	JP	PE,nn			JV	nn
*	JP	PO,nn			JNV	nn
*	JP	PO,nn			JPO	nn
*	JP	Z,nn			JZ	nn
	JR	C,nn			JRC	nn
	JR	NC,nn			JRNC	nn
	JR	nn			JMPR	nn
	JR	NZ,nn			JRNZ	nn
	JR	Z,nn			JRZ	nn
*	LD	(nn),A			STA	nn
	LD	(nn),BC			SBCD	nn
	LD	(nn),DE			SDED	nn
*	LD	(nn),HL			SHLD	nn
	LD	(nn),IX			SIXD	nn
	LD	(nn),IY			SIYD	nn
	LD	(nn),SP			SSPD	nn
*	LD	(zz),A			STAX	zz
*	LD	A,(nn)			LDA	nn
*	LD	A,(zz)			LDAX	zz
	LD	A,I			LDAI
	LD	A,R			LDAR
	LD	BC,(nn)			LBCD	nn
	LD	DE,(nn)			LDED	nn
*	LD	HL,(nn)			LHLD	nn
	LD	I,A			STAI
	LD	IX,(nn)			LIXD	nn
	LD	IY,(nn)			LIYD	nn
*	LD	jj,nn			LXI	jj,nn
	LD	R,A			STAR
*	LD	r,n			MVI	r,n
*	LD	r,s			MOV	r,s
*	LD	s,r			MOV	s,r
	LD	SP,(nn)			LSPD	nn
*	LD	SP,HL			SPHL
	LD	SP,IX			SPIX
	LD	SP,IY			SPIY
	LDD				LDD
	LDDR				LDDR
	LDI				LDI
	LDIR				LDIR
	NEG				NEG
*	NOP				NOP
*	OR	A,n			ORI	n
*	OR	A,s			ORA	s
	OTDR				OUTDR
	OTIR				OUTIR
	OUT	(C),r			OUTP	r
*	OUT	(n),A			OUT	n
	OUTD				OUTD
	OUTI				OUTI
	POP	ii			POP	ii
*	POP	qq			POP	qq
	PUSH	ii			PUSH	ii
*	PUSH	qq			PUSH	qq
	RES	b,s			RES	b,s
*	RET				RET
*	RET	C			RC
*	RET	M			RM
*	RET	NC			RNC
*	RET	NZ			RNZ
*	RET	P			RP
*	RET	PE			RPE
*	RET	PE			RV
*	RET	PO			RNV
*	RET	PO			RPO
*	RET	Z			RZ
	RETI				RETI
	RETN				RETN
	RL	s			RALR	s
*	RLA				RAL
	RLC	s			RLCR	s
*	RLCA				RLC
	RLD				RLD
	RR	s			RARR	s
*	RRA				RAR
	RRC	s			RRCR	s
*	RRCA				RRC
	RRD				RRD
*	RST	n			RST	n/8
*	SBC	A,n			SBI	n
*	SBC	A,s			SBB	s
	SBC	HL,rr			DSBC	rr
*	SCF				STC
	SET	b,s			BSET	b,s
	SLA	s			SLAR	s
	SRA	s			SRAR	s
	SRL	s			SRLR	s
*	SUB	A,n			SUI	n
*	SUB	A,s			SUB	s
*	XOR	A,n			XRI	n
*	XOR	A,s			XRA	s



   Z-80 instructions sorted by bastardized TDL mnemonics


8080?	Standard (Zilog) Z-80		Bastardized (TDL) Z-80


*	ADC	A,n			ACI	n
*	ADC	A,s			ADC	s
*	ADD	A,s			ADD	s
*	ADD	A,n			ADI	n
*	AND	A,s			ANA	s
*	AND	A,n			ANI	n
	BIT	b,s			BIT	b,s
	SET	b,s			BSET	b,s
*	CALL	nn			CALL	nn
*	CALL	C,nn			CC	nn
	CPD				CCD
	CPDR				CCDR
	CPI				CCI
	CPIR				CCIR
*	CALL	M,nn			CM	nn
*	CPL				CMA
*	CCF				CMC
*	CP	A,s			CMP	s
*	CALL	NC,nn			CNC	nn
*	CALL	PO,nn			CNV	nn
*	CALL	NZ,nn			CNZ	nn
*	CALL	P,nn			CP	nn
*	CALL	PE,nn			CPE	nn
*	CP	A,n			CPI	n
*	CALL	PO,nn			CPO	nn
*	CALL	PE,nn			CV	nn
*	CALL	Z,nn			CZ	nn
*	DAA				DAA
*	ADD	HL,rr			DAD	rr
	ADC	HL,rr			DADC	rr
	ADD	IX,tt			DADX	tt
	ADD	IY,uu			DADY	uu
*	DEC	s			DCR	s
*	DEC	jj			DCX	jj
*	DI				DI
	DJNZ	nn			DJNZ	nn
	SBC	HL,rr			DSBC	rr
*	EI				EI
	EX	AF,AF'			EXAF
	EXX				EXX
*	HALT				HLT
	IM	0			IM0
	IM	1			IM1
	IM	2			IM2
*	IN	A,(n)			IN	n
	IND				IND
	INDR				INDR
	INI				INI
	INIR				INIR
	IN	r,(C)			INP	r
*	INC	s			INR	s
*	INC	jj			INX	jj
*	JP	C,nn			JC	nn
*	JP	M,nn			JM	nn
*	JP	nn			JMP	nn
	JR	nn			JMPR	nn
*	JP	NC,nn			JNC	nn
*	JP	PO,nn			JNV	nn
*	JP	NZ,nn			JNZ	nn
*	JP	P,nn			JP	nn
*	JP	PE,nn			JPE	nn
*	JP	PO,nn			JPO	nn
	JR	C,nn			JRC	nn
	JR	NC,nn			JRNC	nn
	JR	NZ,nn			JRNZ	nn
	JR	Z,nn			JRZ	nn
*	JP	PE,nn			JV	nn
*	JP	Z,nn			JZ	nn
	LD	BC,(nn)			LBCD	nn
*	LD	A,(nn)			LDA	nn
	LD	A,I			LDAI
	LD	A,R			LDAR
*	LD	A,(zz)			LDAX	zz
	LDD				LDD
	LDDR				LDDR
	LD	DE,(nn)			LDED	nn
	LDI				LDI
	LDIR				LDIR
*	LD	HL,(nn)			LHLD	nn
	LD	IX,(nn)			LIXD	nn
	LD	IY,(nn)			LIYD	nn
	LD	SP,(nn)			LSPD	nn
*	LD	jj,nn			LXI	jj,nn
*	LD	r,s			MOV	r,s
*	LD	s,r			MOV	s,r
*	LD	r,n			MVI	r,n
	NEG				NEG
*	NOP				NOP
*	OR	A,s			ORA	s
*	OR	A,n			ORI	n
*	OUT	(n),A			OUT	n
	OUTD				OUTD
	OTDR				OUTDR
	OUTI				OUTI
	OTIR				OUTIR
	OUT	(C),r			OUTP	r
*	JP	(HL)			PCHL
	JP	(IX)			PCIX
	JP	(IY)			PCIY
	POP	ii			POP	ii
*	POP	qq			POP	qq
	PUSH	ii			PUSH	ii
*	PUSH	qq			PUSH	qq
*	RLA				RAL
	RL	s			RALR	s
*	RRA				RAR
	RR	s			RARR	s
*	RET	C			RC
	RES	b,s			RES	b,s
*	RET				RET
	RETI				RETI
	RETN				RETN
*	RLCA				RLC
	RLC	s			RLCR	s
	RLD				RLD
*	RET	M			RM
*	RET	NC			RNC
*	RET	PO			RNV
*	RET	NZ			RNZ
*	RET	P			RP
*	RET	PE			RPE
*	RET	PO			RPO
*	RRCA				RRC
	RRC	s			RRCR	s
	RRD				RRD
*	RST	n			RST	n/8
*	RET	PE			RV
*	RET	Z			RZ
*	SBC	A,s			SBB	s
	LD	(nn),BC			SBCD	nn
*	SBC	A,n			SBI	n
	LD	(nn),DE			SDED	nn
*	LD	(nn),HL			SHLD	nn
	LD	(nn),IX			SIXD	nn
	LD	(nn),IY			SIYD	nn
	SLA	s			SLAR	s
*	LD	SP,HL			SPHL
	LD	SP,IX			SPIX
	LD	SP,IY			SPIY
	SRA	s			SRAR	s
	SRL	s			SRLR	s
	LD	(nn),SP			SSPD	nn
*	LD	(nn),A			STA	nn
	LD	I,A			STAI
	LD	R,A			STAR
*	LD	(zz),A			STAX	zz
*	SCF				STC
*	SUB	A,s			SUB	s
*	SUB	A,n			SUI	n
*	EX	DE,HL			XCHG
*	XOR	A,s			XRA	s
*	XOR	A,n			XRI	n
*	EX	(SP),HL			XTHL
	EX	(SP),IX			XTIX
	EX	(SP),IY			XTIY





	(************************************************)
	(*						*)
	(*		STRING LIBRARY			*)
	(*						*)
	(************************************************)




(*	Version 3.0  31 May 1980/Raymond E. Penley *)

	(************************************************)



FUNCTION INDEX(SOURCE,Pattern) : INTEGER ; EXTERNAL;
	(*---this is a Pascal/Z extension---*)

	Returns the position of the first occurrence of the
Pattern in SOURCE to be scanned. The integer value of the
position of the first character in the matched pattern will
be returned. If no match occurred then zero will be returned.

  If for example the string THIS contained:
	'Today is the first day.'
	PATTERN := 'is';
	N := INDEX(THIS,pattern);
	writeln(N);

	would write:	7

	(****************************************)
	(*	UCSD PASCAL			*)
	(*					*)
	(* 	K := POS(Pattern,SOURCE);	*)
	(*					*)
	(* NOTE that Pascal/Z is 180 degrees	*)
	(* out of wack!				*)
	(****************************************)

	(************************************************)



PROCEDURE PRINT(STRING);

  Prints to the console the string passed; does NOT issue a
  carriage-return/line-feed. 

	PRINT(This);	  	{no CR/LF	}
	PRINT(This);writeln;	{with CR/LF	}
	PRINT(A[5]);write('    ');PRINT(Newstr);writeln;

	(************************************************)



PROCEDURE COPY(New_string,Source,POS,COUNT);

	COPY(<NEW> := <SOURCE>,<starting at>,<# of chars>);
	COPY(Newstr,Title,1,9);

	Returns a string containing count <chars> starting at
	<POS> position in SOURCE.

	(*****************************************)
	(*	UCSD PASCAL			 *)
	(*					 *)
	(* New_string := COPY(Source,POS,COUNT); *)
	(*					 *)
	(*****************************************)

	(************************************************)



PROCEDURE CONCAT(New_string,arg1_string,arg2_string);

	CONCAT(Newstr,ThisString, ThatString);

	This CONCAT works in the same fashion as CPM's PIP does.
  That is:
		CONCAT( New String := Arg1, Arg2 );

  There may be only two arguments. A string is returned which is
  the concatenation of both strings passed provided that the 
  combined length of all strings does not exceed the max length
  allowed for strings.

	(********************************************)
	(*	UCSD PASCAL			    *)
	(*					    *)
	(* New_string := CONCAT(arg1,arg2,...argn); *)
	(*					    *)
	(********************************************)

	(************************************************)



PROCEDURE REPLACE(Source, Destination, INDEX);

	REPLACE(Main,Next,N);
	PRINT(Next);

	Replaces the characters in Destination with those
  from the substring Source starting at position INDEX.


	(*****************************************)
	(*	UCSD PASCAL			 *)
	(*					 *)
	(* INSERT(SOURCE,DESTINATION,INDEX);	 *)
	(*					 *)
	(*****************************************)

	(************************************************)



PROCEDURE GetLine(STRING,count);

	Returns a string and the strings length input
 from the console. The string must be a valid ASCII
 character. Returns a length of zero if an error is
 made.

  For example:

	GetLine(BUFFER,12);

	Gets characters from the console into the String 'BUFFER'
  but up to a max of 12 characters.

	(***********************************************)

